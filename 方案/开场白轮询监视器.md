
# 技术方案文档：开场白轮询监视器

**版本**: 1.0
**状态**: ✅ 已实现 (2025-12-21)
**目的**: 解决"非标准方式切换开场白"导致播放器无法感知变化的问题

---

## 一、问题背景

### 1.1 现象描述

用户在使用某些角色卡时，点击角色卡内嵌的前端界面按钮跳转到另一个开场白后，音乐播放器显示"没有歌单"，即使新开场白明确配置了歌单标签。

### 1.2 根本原因

当前脚本仅通过监听 `MESSAGE_SWIPED` 事件来感知开场白的切换：

```typescript
eventOn(tavern_events.MESSAGE_SWIPED, (rawId: string | number) => {
  // ...
  if (id === 0) {
    void _executeSoftReset({ autoPlayIfWasPlaying: wasPlaying });
  }
});
```

然而，某些角色卡的前端界面通过非原生方式（如直接调用酒馆内部API、修改 `swipe_id` 后调用渲染函数、使用 `setChatMessages` 等）来切换开场白。这些方式**不会触发** `MESSAGE_SWIPED` 事件，导致我们的脚本完全感知不到开场白已经变化。

### 1.3 证据链

1. 控制台日志中完全没有 `[Event-Swipe]` 相关记录
2. 用户通过原生左右滑动切换开场白时，功能正常
3. 用户通过前端按钮跳转时，功能失效
4. `swipe_id` 确实发生了变化（可通过控制台验证）

---

## 二、解决方案概述

### 2.1 核心思路

利用**轮询机制**主动监控 `swipe_id` 的变化，而非依赖事件系统。

### 2.2 设计原则

| 原则                     | 应用方式                                                         |
| ------------------------ | ---------------------------------------------------------------- |
| **SSoT（单一事实来源）** | `_lastActiveSwipeId` 是 swipe_id 的唯一记忆来源                  |
| **SRP（单一职责）**      | 轮询监视器只负责"检测变化"，软重置逻辑委托给 `_executeSoftReset` |
| **KISS（保持简单）**     | 复用现有的 `_lastActiveSwipeId` 和 `_executeSoftReset` 机制      |
| **OCP（开闭原则）**      | 不修改现有的 `MESSAGE_SWIPED` 处理逻辑，只增加新的监控机制       |

### 2.3 方案优势

1. **兼容性强**：无论前端界面用什么方式跳转开场白，只要 `swipe_id` 发生变化，我们都能感知
2. **复用现有机制**：直接利用 `StateManager.getLastActiveSwipeId()` 和 `_executeSoftReset()`
3. **最小侵入**：不修改任何现有逻辑，只增加一道"安全网"
4. **精准高效**：只在真正需要监控的时候运行（开场白阶段），聊天开始后自动停止

---

## 三、详细设计

### 3.1 轮询监视器的生命周期

```
┌─────────────────────────────────────────────────────────────────┐
│                        轮询监视器生命周期                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────────┐                                               │
│  │ 脚本初始化完成 │                                               │
│  └──────┬───────┘                                               │
│         │                                                       │
│         ▼                                                       │
│  ┌──────────────┐    是     ┌─────────────┐                     │
│  │ 消息数 = 1？  │─────────▶│ 启动轮询监视器 │                     │
│  └──────┬───────┘          └──────┬──────┘                     │
│         │ 否                      │                             │
│         ▼                         ▼                             │
│  ┌──────────────┐          ┌─────────────┐                     │
│  │ 不启动监视器  │          │ 每250ms检查  │◀─────┐              │
│  └──────────────┘          └──────┬──────┘      │              │
│                                   │              │              │
│                                   ▼              │              │
│                          ┌───────────────┐      │              │
│                          │ 消息数仍然=1？ │      │              │
│                          └───────┬───────┘      │              │
│                                  │              │              │
│                    ┌─────────────┴─────────────┐│              │
│                    │ 是                      否 ││              │
│                    ▼                          ▼ │              │
│           ┌────────────────┐         ┌─────────┴┐              │
│           │ swipe_id变化？ │         │ 停止监视器│              │
│           └───────┬────────┘         └──────────┘              │
│                   │                                             │
│         ┌─────────┴─────────┐                                   │
│         │ 是              否 │                                   │
│         ▼                  ▼                                    │
│  ┌──────────────┐   ┌───────────┐                               │
│  │执行软重置     │   │ 继续下一轮 │───────────────────────────────┘│
│  └──────────────┘   └───────────┘                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 启动条件（详细）

轮询监视器在以下两种情况下启动：

**情况A：初始化完成时**
- 在 `initializePlayerForChat` 函数执行完毕后
- 检查当前聊天消息数
- 如果消息数 = 1（只有开场白），启动监视器

**情况B：消息删除后**
- 在 `MESSAGE_DELETED` 事件处理完成后
- 检查删除后的聊天消息数
- 如果消息数 = 1（回到了只有开场白的状态），启动监视器

### 3.3 停止条件（详细）

轮询监视器在以下情况下停止：

| 条件         | 触发点              | 说明                             |
| ------------ | ------------------- | -------------------------------- |
| 消息数 > 1   | 轮询检测时          | 用户开始了正式聊天，开场白已固定 |
| 脚本卸载     | `pagehide` 事件     | 整个脚本生命周期结束             |
| 聊天切换     | `CHAT_CHANGED` 事件 | 上下文完全变更，需要硬重置       |
| 软重置执行中 | 轮询检测时          | 避免在重置过程中重复操作         |

### 3.4 轮询参数

| 参数         | 值    | 说明                     |
| ------------ | ----- | ------------------------ |
| 轮询间隔     | 250ms | 平衡响应速度与性能开销   |
| 最大感知延迟 | 250ms | 用户点击后最多等待此时间 |

### 3.5 swipe_id 获取方式

使用封装的 `getChatMessages` API：

```typescript
const msgZero = getChatMessages(0, { include_swipes: true })[0];
const currentSwipeId = msgZero?.swipe_id ?? 0;
```

**选择理由**：
1. 与 `initializePlayerForChat` 中的现有写法保持一致
2. 便于理解和维护
3. 由酒馆助手团队维护，接口稳定

---

## 四、与现有机制的协调

### 4.1 与 MESSAGE_SWIPED 事件的关系

**保留现有的 `MESSAGE_SWIPED` 监听逻辑不变**。

两者的关系是"双保险"：
- `MESSAGE_SWIPED`：处理原生滑动方式（响应更快，事件驱动）
- 轮询监视器：处理非标准方式（兜底保障，主动探测）

### 4.2 防止重复触发的机制

当用户使用原生滑动时，`MESSAGE_SWIPED` 和轮询可能"几乎同时"检测到变化。为防止重复执行软重置，需要在 `_executeSoftReset` 中添加互斥锁。

**时序分析（无锁情况下的问题）**：

```
T=150ms  MESSAGE_SWIPED 事件触发，读取 lastSwipeId=0, currentSwipeId=1
T=151ms  轮询器也检测到变化，读取 lastSwipeId=0, currentSwipeId=1
T=152ms  两者都判断"有变化"，都调用 _executeSoftReset
         → 软重置被执行两次！
```

**时序分析（有锁情况下的正确行为）**：

```
T=150ms  MESSAGE_SWIPED 触发，获取锁成功，开始执行软重置
T=151ms  轮询器检测到变化，尝试获取锁，失败
T=152ms  轮询器直接返回，不执行任何操作
T=300ms  MESSAGE_SWIPED 的软重置完成，更新 lastSwipeId=1，释放锁
T=400ms  轮询器下一轮检测，currentSwipeId=1, lastSwipeId=1
         → 判断"无变化"，不做任何事
```

### 4.3 锁的工作原理

```typescript
let _isSoftResetting = false;  // 软重置锁

async function _executeSoftReset(options) {
  // 尝试获取锁
  if (_isSoftResetting) {
    logProbe('[SoftReset] 请求被合并：已有软重置正在进行中。', 'warn');
    return;  // 锁被占用，直接返回
  }

  _isSoftResetting = true;  // 获取锁

  try {
    // ... 执行软重置逻辑 ...
  } finally {
    _isSoftResetting = false;  // 无论成功失败，都释放锁
  }
}
```

---

## 五、代码修改清单

### 5.1 新增全局变量

**位置**：在 `let isScriptActive = true;` 附近

```typescript
// 软重置互斥锁，防止 MESSAGE_SWIPED 和轮询监视器同时触发软重置
let _isSoftResetting = false;

// 开场白轮询监视器的定时器句柄
let _greetingWatcherTimer: number | null = null;
```

### 5.2 新增函数：启动轮询监视器

**位置**：建议放在 `_executeSoftReset` 函数附近

```typescript
/**
 * [V9.5 新增] 启动开场白轮询监视器。
 *
 * 职责：定期检查 swipe_id 是否发生变化，以兼容"非标准"的开场白切换方式。
 *
 * 生命周期：
 * - 启动：初始化完成且消息数=1，或 MESSAGE_DELETED 后消息数=1
 * - 停止：消息数不等于1，或脚本卸载/聊天切换
 */
function _startGreetingWatcher() {
  // 防止重复启动
  if (_greetingWatcherTimer !== null) {
    logProbe('[GreetingWatcher] 监视器已在运行中，忽略重复启动请求。');
    return;
  }

  logProbe('[GreetingWatcher] 启动开场白轮询监视器 (间隔: 250ms)...');

  _greetingWatcherTimer = window.setInterval(() => {
    // 前置检查1：脚本是否仍然活跃
    if (!isScriptActive) {
      _stopGreetingWatcher();
      return;
    }

    // 前置检查2：核心是否已初始化
    if (!isCorePlayerInitialized) {
      return;  // 还没初始化完成，静默等待
    }

    // 前置检查3：是否有软重置正在进行
    if (_isSoftResetting) {
      return;  // 软重置进行中，跳过本轮检测
    }

    // 检查消息数量
    const chatLength = SillyTavern.chat?.length ?? 0;

    if (chatLength !== 1) {
      // 消息数不再是1，说明用户已开始聊天，开场白已固定
      logProbe(`[GreetingWatcher] 检测到消息数=${chatLength}，开场白阶段结束，停止监视器。`);
      _stopGreetingWatcher();
      return;
    }

    // 获取当前 swipe_id
    const msgZero = getChatMessages(0, { include_swipes: true })[0];
    const currentSwipeId = msgZero?.swipe_id ?? 0;
    const lastSwipeId = StateManager.getLastActiveSwipeId();

    // 对比是否发生变化
    if (currentSwipeId === lastSwipeId) {
      return;  // 无变化，继续下一轮检测
    }

    // 检测到变化！
    logProbe(
      `[GreetingWatcher] 检测到开场白变化: swipe ${lastSwipeId} -> ${currentSwipeId}`,
      'warn'
    );

    // 记录当前播放状态，用于决定软重置后是否自动播放
    const wasPlaying = StateManager.isPlaying();
    logProbe(`[GreetingWatcher] 操作前的播放状态: ${wasPlaying}`);

    // 执行软重置
    void _executeSoftReset({ autoPlayIfWasPlaying: wasPlaying });

  }, 250);  // 250ms 轮询间隔
}
```

### 5.3 新增函数：停止轮询监视器

**位置**：紧跟在 `_startGreetingWatcher` 之后

```typescript
/**
 * [V9.5 新增] 停止开场白轮询监视器。
 *
 * 此函数可以安全地被多次调用。
 */
function _stopGreetingWatcher() {
  if (_greetingWatcherTimer !== null) {
    clearInterval(_greetingWatcherTimer);
    _greetingWatcherTimer = null;
    logProbe('[GreetingWatcher] 轮询监视器已停止。');
  }
}
```

### 5.4 修改函数：_executeSoftReset

**修改内容**：在函数开头添加互斥锁检查

```typescript
async function _executeSoftReset(options?: { autoPlayIfWasPlaying?: boolean }) {
  // ========== 新增：互斥锁检查 ==========
  if (_isSoftResetting) {
    logProbe('[SoftReset] 请求被合并：已有软重置正在进行中。', 'warn');
    return;
  }
  _isSoftResetting = true;
  // ========== 新增结束 ==========

  logProbe('[SoftReset] 检测到根本性上下文变更，启动"软重置"协议...', 'warn');

  try {
    // ... 原有的软重置逻辑保持不变 ...

    const config = await parseWorldbookConfig();
    if (!config) {
      logProbe('[SoftReset] 配置解析失败，软重置中止。', 'error');
      return;
    }

    let authoritativeState = null;
    if (config.isMvu) {
      logProbe('[SoftReset] (MVU模式) 正在为新的开场白查找权威MVU状态...');
      authoritativeState = await _findLatestAuthoritativeMvuState();
    } else {
      logProbe('[SoftReset] (文本模式) 正在为新的开场白解析文本标签...');
      const textResult = await TextTagManager.getLatestState();
      authoritativeState = {
        mvuData: { stat_data: textResult.tags },
        messageId: textResult.foundAtMessageId,
      };
    }

    await initializePlayerForChat(config, authoritativeState, options);

  } catch (error) {
    logProbe('[SoftReset] 软重置过程中发生严重错误。', 'error');
    console.error(error);
  } finally {
    // ========== 新增：释放互斥锁 ==========
    _isSoftResetting = false;
    // ========== 新增结束 ==========
  }
}
```

### 5.5 修改函数：initializePlayerForChat

**修改内容**：在函数末尾（成功完成后）添加监视器启动逻辑

**位置**：在 `logProbe('=== 【核心·自愈式初始化】执行完毕 ===', 'groupEnd');` 之前

```typescript
    // ... 原有代码 ...

    if (options?.autoPlayIfWasPlaying) {
      logProbe('[Initializer] (探针) 检测到来自开场白滑动的"自动播放"意图。', 'warn');
      const currentItem = StateManager.getTopQueueItem();
      if (currentItem) {
        logProbe('[Initializer] 新的开场白已配置歌单，将执行"创世播放"...');
        await _handleGenesisPlay();
      } else {
        logProbe('[Initializer] 新的开场白未配置歌单，自动播放已取消。');
      }
    }

    // ========== 新增：根据消息数量决定是否启动轮询监视器 ==========
    const chatLength = SillyTavern.chat?.length ?? 0;
    if (chatLength === 1) {
      logProbe('[Initializer] 当前处于开场白阶段 (消息数=1)，启动轮询监视器。');
      _startGreetingWatcher();
    } else {
      logProbe(`[Initializer] 当前消息数=${chatLength}，无需启动轮询监视器。`);
      // 确保没有残留的监视器在运行
      _stopGreetingWatcher();
    }
    // ========== 新增结束 ==========

  } catch (error) {
    // ... 原有错误处理 ...
  } finally {
    logProbe('=== 【核心·自愈式初始化】执行完毕 ===', 'groupEnd');
  }
}
```

### 5.6 修改事件处理：MESSAGE_DELETED

**位置**：在 `_registerContextualEventListeners` 函数中

**修改内容**：在 `_handleHistoryChangeEvent` 调用之后，添加监视器启动检查

```typescript
eventOn(tavern_events.MESSAGE_DELETED, (rawDeletedId: string | number) => {
  const deletedId = Number(rawDeletedId);
  if (isNaN(deletedId)) return;

  if (!isScriptActive) return;
  logProbe(`[EventAdapter] 捕获到删除事件 (原ID: ${deletedId})，正在通过"高级历史通道"触发全量校准...`);

  // 原有的校准逻辑
  void _handleHistoryChangeEvent('MESSAGE_DELETED').then(() => {
    // ========== 新增：删除后检查是否需要重新启动监视器 ==========
    const chatLength = SillyTavern.chat?.length ?? 0;
    if (chatLength === 1) {
      logProbe('[EventAdapter] 删除后消息数=1，重新启动轮询监视器。');
      _startGreetingWatcher();
    }
    // ========== 新增结束 ==========
  });
});
```

### 5.7 修改清理逻辑：pagehide 事件

**位置**：在主执行区的 `$(window).on('pagehide', ...)` 中

**修改内容**：添加监视器清理

```typescript
$(window).on('pagehide', () => {
  logProbe('PAGEHIDE 事件触发！', 'warn');

  // ========== 新增：停止轮询监视器 ==========
  _stopGreetingWatcher();
  // ========== 新增结束 ==========

  PlaybackEngine.getActivePlayer()?.pause();
  logProbe('音频已暂停。');

  // ... 其余清理逻辑保持不变 ...
});
```

### 5.8 修改清理逻辑：executeHardReset 函数

**位置**：在 `executeHardReset` 函数中

**修改内容**：添加监视器清理

```typescript
function executeHardReset() {
  logProbe('[HardReset] "优雅停机"协议启动...', 'warn');

  isScriptActive = false;

  // ========== 新增：停止轮询监视器 ==========
  _stopGreetingWatcher();
  // ========== 新增结束 ==========

  PlaybackEngine.getActivePlayer()?.pause();
  logProbe('[HardReset] 音频已暂停。');

  logProbe('[HardReset] 即将调用 reloadIframe()。');
  reloadIframe();
}
```

---

## 六、测试验证清单

### 6.1 功能测试

| 测试场景               | 预期结果                     | 验证方法                                            |
| ---------------------- | ---------------------------- | --------------------------------------------------- |
| 原生滑动切换开场白     | 正常触发软重置，歌单正确切换 | 观察控制台日志，确认只有一次软重置                  |
| 前端按钮跳转开场白     | 正常触发软重置，歌单正确切换 | 观察控制台日志，确认 `[GreetingWatcher]` 检测到变化 |
| 用户发送第一条消息     | 监视器自动停止               | 观察控制台日志，确认出现"停止监视器"日志            |
| 删除所有消息只剩开场白 | 监视器重新启动               | 观察控制台日志，确认出现"重新启动"日志              |
| 切换聊天/刷新页面      | 监视器正确清理               | 无报错，无内存泄漏                                  |

### 6.2 边界测试

| 测试场景                 | 预期结果                           |
| ------------------------ | ---------------------------------- |
| 快速连续切换开场白       | 只执行一次软重置（锁机制生效）     |
| 同时原生滑动和按钮点击   | 只执行一次软重置（锁机制生效）     |
| 在软重置过程中切换开场白 | 新请求被合并，日志显示"请求被合并" |
| 角色卡没有配置歌单       | 不崩溃，正常提示"配置缺失"         |

### 6.3 性能测试

| 指标                | 预期值            |
| ------------------- | ----------------- |
| 轮询期间的 CPU 占用 | 几乎无感知（<1%） |
| 轮询期间的内存增长  | 无增长            |
| 感知延迟            | 最大 250ms        |

---

## 七、日志输出规范

### 7.1 正常流程日志示例

```
[GreetingWatcher] 启动开场白轮询监视器 (间隔: 250ms)...
[GreetingWatcher] 检测到开场白变化: swipe 0 -> 1
[GreetingWatcher] 操作前的播放状态: false
[SoftReset] 检测到根本性上下文变更，启动"软重置"协议...
... (软重置日志) ...
```

### 7.2 监视器停止日志示例

```
[GreetingWatcher] 检测到消息数=2，开场白阶段结束，停止监视器。
[GreetingWatcher] 轮询监视器已停止。
```

### 7.3 锁合并日志示例

```
[GreetingWatcher] 检测到开场白变化: swipe 0 -> 1
[SoftReset] 请求被合并：已有软重置正在进行中。
```

---

## 八、风险评估

| 风险           | 可能性 | 影响 | 缓解措施                          |
| -------------- | ------ | ---- | --------------------------------- |
| 轮询性能开销   | 低     | 低   | 每250ms仅读取一次轻量数据，可忽略 |
| 锁死锁         | 极低   | 高   | finally 块中始终释放锁            |
| 与其他脚本冲突 | 低     | 中   | 使用唯一命名的变量和函数          |
| 酒馆API变更    | 低     | 高   | 使用封装的官方API而非直接内存读取 |

---

## 九、版本兼容性

- **最低酒馆版本**：需支持 `getChatMessages` API
- **最低酒馆助手版本**：需支持 `include_swipes` 参数
- **浏览器要求**：支持 `setInterval`（所有现代浏览器均支持）

---

## 十、附录：完整代码差异摘要

```
文件: index.ts

+ let _isSoftResetting = false;
+ let _greetingWatcherTimer: number | null = null;

+ function _startGreetingWatcher() { ... }
+ function _stopGreetingWatcher() { ... }

~ function _executeSoftReset() {
+   if (_isSoftResetting) return;
+   _isSoftResetting = true;
    ...
+   finally { _isSoftResetting = false; }
  }

~ function initializePlayerForChat() {
    ...
+   if (chatLength === 1)
