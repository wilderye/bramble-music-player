
---

### **项目知识库 V1.1**

**文档版本**: 1.1
**状态**: **已批准 (Approved)**
**目的**: 本文档是项目开发所依赖的“唯一事实来源 (SSoT)”，记录了所有关于外部环境（Silly Tavern、MVU 框架、浏览器）的核心定律与运作机理。

---

### **第一部分：Silly Tavern 环境的核心定律**

本部分描述了我们脚本所运行的宿主环境——Silly Tavern 的基本规则。

#### 1.1. 脚本的生命周期与上下文持久性

*   **单一实例原则**: 在同一个浏览器页面会话中，无论用户如何刷新页面、新建聊天或切换角色卡，我们的脚本文件都**只会被加载和执行一次**。我们不需要担心多个脚本实例同时存在并互相干扰的问题。

*   **加载时序与上下文持久性：两种核心场景**
    我们必须深刻理解，脚本的生命周期存在两种截然不同的核心场景。错误地将一种场景的规律套用在另一种上，是导致架构错误的根源。

    *   **场景一：脚本被卸载并重载 (Script is Unloaded & Reloaded)**
        *   **触发条件**:
            1.  **切换不同角色卡**时。
            2.  用户**按 F5 刷新**整个浏览器页面时。
        *   **关键行为**: 在这些场景下，旧脚本的 `pagehide` 事件会被触发，整个脚本实例被销毁。
        *   **时序定律 (此场景下依然有效)**:
            1.  旧的聊天环境被卸载，旧脚本的 `pagehide` 事件被触发。
            2.  Silly Tavern 的核心事件，如 `CHAT_CHANGED` 和初始的 `CHARACTER_MESSAGE_RENDERED`，在一个**没有我们脚本存在的“真空环境”中被触发并结束**。
            3.  **最后**，Silly Tavern 才会加载并启用我们的新脚本。
        *   **核心结论**: 在此场景下，任何依赖**监听** `CHAT_CHANGED` 或初始 `CHARACTER_MESSAGE_RENDERED` 事件来触发核心初始化的方案，在架构上都是根本性错误的。我们必须采用**主动观察**环境状态的方式（我们的“观察者模型”）来确认初始化时机。

    *   **场景二：脚本实例持续存在 (Script Instance Persists)**
        *   **触发条件**:
            1.  在**同一角色卡内，切换不同的聊天文件**时。
        *   **关键行为**: 在这个场景下，脚本实例**不会被卸载**，`pagehide` 事件也**不会被触发**。我们的脚本作为一个长期存活的服务，完整地经历了上下文的切换。
        *   **时序定律**:
            1.  Silly Tavern 触发 `CHAT_CHANGED` 事件。
            2.  由于我们的脚本实例依然存活，我们注册的 `eventOn(tavern_events.CHAT_CHANGED, ...)` 监听器**能够成功捕获此事件**。
        *   **核心结论**: 在此场景下，我们**可以也必须**通过监听 `CHAT_CHANGED` 事件来感知上下文的变化。但这也带来了新的责任：我们必须在代码中实现**手动的状态清理与再初始化（软重置）**，以防止旧聊天的状态（如播放模式、音量、播放列表）污染到新聊天中。

*   **卸载陷阱：
    *   **适用场景**: 此陷阱主要发生于上述的**“场景一”**中。
    *   **`pagehide` 事件的“跨上下文污染”**: 当用户切换聊天时，会触发旧脚本的 `pagehide` 卸载事件。在这个事件的处理器执行时，一个致命的时序问题已经发生：
    *   酒馆助手的 API 上下文（例如 `updateVariablesWith` 的目标聊天区）已经**提前切换到了新的聊天环境**。
    *   浏览器不会等待 `pagehide` 事件中的任何异步操作（如 `await`）完成。
    *   **核心结论**: 任何试图在 `pagehide` 事件中执行**异步**的、依赖聊天上下文的**写入操作**，都必然会导致灾难性的数据污染。旧脚本的内存状态，会被写入到新聊天的变量中。因此，`pagehide` 事件**只能**用于执行完全**同步**的、与聊天上下文无关的清理操作（例如，立即暂停音频）。

#### **1.2. 核心 API: `setChatMessages` 的运作机制**

*   **机制是“合并/补丁”，而非“覆盖”**: `setChatMessages` 函数的行为是一个**合并 (Merge)** 或**补丁 (Patch)** 操作。当你调用它时，你只需要提供你想要改变的字段（如 `message` 或 `data`），Silly Tavern 会将你提供的新数据与服务器上已有的消息数据进行合并。任何你没有提供的字段将保持原样，不会被清除或覆盖。

*   **脚本冲突的根源：“读-改-写”竞态条件**: 早期脚本互相挤占 UI 的问题，源于一个经典的“竞态条件”。当两个脚本几乎同时执行以下操作时，冲突就会发生：
    1.  **读取 (Read)**: 两个脚本都读取了同一条原始消息。
    2.  **修改 (Modify)**: 两个脚本都在**各自的内存副本**上追加了不同的内容。
    3.  **写入 (Write)**: 两个脚本先后调用 `setChatMessages`。后一个写入的脚本，会用它自己的、基于陈旧原始消息的修改结果，**完全覆盖**掉前一个脚本的写入。这就是“最后写入者获胜”原则。
    *   **核心结论**: 为了与其他脚本和平共存，我们必须设计自己的注入逻辑，使其能够在这种潜在的竞争环境中健壮地运行。

*   **事件触发**: 当使用 `refresh: 'affected'` (默认值) 或 `refresh: 'all'` 选项调用 `setChatMessages` 时，Silly Tavern 会重新渲染受影响的消息楼层，并因此触发 `USER_MESSAGE_RENDERED` 或 `CHARACTER_MESSAGE_RENDERED` 事件。

#### 1.3. 核心数据结构：ChatMessage 对象

*   **`message_id` 是唯一的真理**: 当我们通过 `getChatMessages` 获取消息列表时，返回的每一个消息对象，其数字 ID 都存储在 `message_id` 这个属性中。
*   **“陷阱”**: 消息对象中**不存在**名为 `id` 的属性。在代码中错误地使用 `message.id` 会得到 `undefined`，这虽然不一定会直接导致程序崩溃，但会将一个无效的 ID 传递给下游的函数，从而引发难以追踪的“幽灵”BUG。
*   **核心结论**: 任何需要使用消息 ID 的代码，都**必须**从 `message.message_id` 属性中读取。
---

### **第二部分：MVU 框架的运作机理**

本部分详细描述了我们深度交互的外部系统——MVU 变量框架的内部工作流程。**其核心设计哲学是有限状态机 (FSM)**。这意味着，任何一个消息楼层的变量状态，都应被视为其前一个有效楼层状态，加上本楼层文本中变量更新指令后，进行纯函数计算得出的唯一结果。理解这一核心原则，是理解其所有行为的关键。

#### **2.1. “创世”阶段：初始变量的诞生**

这是指在一个新聊天会话被创建时，MVU 如何为开场白（`message_id: 0`）建立初始变量状态。

1.  **触发时机**: 在第一个开场白生成时，MVU 的 `initCheck` 函数会被触发。

2.  **基准状态的建立**: `initCheck` 会首先扫描所有已启用的世界书，找到所有带 `[initvar]` 标签的条目。它会解析这些条目的内容（YAML, JSON, 或 TOML 格式），并将它们**深度合并 (merge)** 成一个单一的、基础的 `stat_data` 对象。这个对象是所有开场白的“共同祖先”和起点。

3.  **开场白专属变量的计算**: 接下来，`initCheck` 会启动一个循环，遍历**每一个**开场白（swipe）的内容文本。在循环的每一步，它都会以“基准 `stat_data`”为基础，调用其核心的 `updateVariables` 函数，来解析并应用该开场白内容中独有的变量更新命令（如 `_.set()`）。这个过程会为**每一个**开场白，都生成一个**最终的、独一无二的 `MvuData` 对象**。

4.  **原子性写入**: `initCheck` 会将上一步为每个开场白生成的所有独立的 `MvuData` 对象，收集到一个名为 `swipes_data` 的数组中。然后，它通过**一次** `setChatMessages` 调用，将这个包含所有独立变量状态的 `swipes_data` 数组，原子性地写入到消息楼层 #0 的变量中。

5.  **“沉默的事件风暴”**: 在上述第 3 步的循环中，`updateVariables` 函数**确实会**为每一个开场白的计算都触发一次 `VARIABLE_UPDATE_ENDED` 事件。然而，这些事件的载荷中**不包含任何能够区分它们对应哪个开场白（swipe）的上下文信息**。
    *   **核心结论**: 在创世阶段，试图通过监听事件来将变量状态与特定开场白一一对应是不可靠的。唯一的权威事实来源，是 `initCheck` 流程全部结束后，被写入到消息楼层 #0 的 `swipes_data` 数组。

#### **2.2. “运行时”阶段：增量式更新**

这是指在聊天进行中，MVU 如何响应新消息并更新变量。

1.  **线性的、向前的更新流**: MVU 的设计哲学是**增量式**的。当一条新消息（无论是用户发送还是 AI 回复）出现时，MVU 的 `handleVariablesInMessage` 函数会被触发。它会：
    a.  向上查找，找到**上一个**有效消息楼层，读取其 `MvuData` 作为本次更新的**起点**。
    b.  解析**当前**新消息中的变量命令，并应用在内存中的数据上。
    c.  将修改后的**最终结果**，写回到**当前**新消息楼层的变量中，并同步到顶层聊天变量，为下一次更新做准备。**这一过程的确定性和可重复性，是 MVU 新增的“重演 (Replay)”功能得以实现的基础。**

2.  **“两段式”工作模式（额外输出）**: 当用户启用“额外模型解析”时，MVU 的工作流变为“两段式”：
    a.  **第一段**: 正常接收 AI 的角色扮演回复。
    b.  **第二段**: MVU 内部会构造一个专门用于分析变量的提示词，并**再次调用一次 LLM API**。
    c.  它会从这次专属调用的结果中，提取出被 `<UpdateVariable>` 标签包裹的变量更新代码。
    d.  **最后**，它会将这段代码**追加**到第一段收到的原始 AI 回复的**末尾**，然后才调用标准的 `handleVariablesInMessage` 函数进行统一处理。
    *   **核心结论**: “额外输出”模式只是 MVU 在上游准备输入数据的一种更复杂的方式。对于在下游监听最终结果的我们来说，我们处理的输入依然是一条单一的、只是被拼接过的消息。

3.*   **“时序悖论”定律**: MVU 的 `VARIABLE_UPDATE_ENDED` 事件，是在其内部 `updateVariables` 函数完成了所有内存计算之后，但在数据被持久化写入到酒馆变量**之前**被触发的。
    *   **核心结论 1**: 在 `VARIABLE_UPDATE_ENDED` 事件的回调函数执行的那个精确瞬间，其**事件载荷 (`MvuData`) 是内存中唯一的真理**。此时通过官方查询接口（`Mvu.getMvuData`）获取数据，必然会读到过时的、陈旧的状态。
    *   **核心结论 2 (新)**: 根据探针确认，此事件的载荷 (`eventPayload`) 采用的是上文定义的**“运行时”结构 (形态 B)**，即 `stat_data` 直接位于载荷对象的顶层。

  *   **“API 行为陷阱”定律 (新)**: `Mvu.getMvuData` 接口存在一个“优雅失败”的 fallback 行为。
    *   **行为**: 当向 `Mvu.getMvuData({ type: 'message', message_id: ... })` 传入一个无效的 `message_id` (例如 `undefined`) 时，该函数**不会报错**，而是会默认返回**最新消息 (`latest`)** 的变量数据。
    *   **核心结论**: 这是一个危险的“陷阱”。它可能导致代码中的 BUG (如拼写错误) 不被发现，反而产生“意外成功”的假象，从而增加调试的复杂性。

#### **2.3. 功能的“盲点”**

根据对 MVU `main.txt` 的分析，MVU 的核心事件循环**没有**为以下改变聊天历史的事件注册任何监听器：
*   `tavern_events.MESSAGE_SWIPED` （消息滑动，包括开场白滑动）
*   `tavern_events.MESSAGE_DELETED` （消息删除）
*   **核心结论**: MVU 的状态链一旦形成，就不会因为历史被用户手动改变而自动重新计算。在这些场景下，维护世界状态的一致性，依赖于像我们这样的外部脚本主动进行校准。

#### **2.4. 数据存储与持久化**

*   **存储位置**: MVU 的核心数据（`stat_data`, `display_data`, `delta_data`, `schema`）**全部**存储在**消息楼层的变量 (`swipes_data`)** 中。
*   **持久化隔离**: MVU 在顶层的聊天变量中，没有使用任何我们已知的、用于自身持久化的自定义键。
    *   **核心结论**: 我们可以安全地在顶层聊天变量中创建自己的持久化键（例如，为 `MvuManager` 创建 `music_player_mvu_history`），而无需担心与 MVU 框架本身发生命名冲突。

*   **初始状态的“变量污染”问题**: MVU 在执行其首次初始化 (`initCheck`) 时，会读取**整个聊天变量 (`getVariables({ type: 'chat' })`) 对象**，并将其作为自己 `stat_data` 的初始基底。
    *   **核心结论**: 如果我们的脚本在 MVU 完成初始化扫描之前，将自己的任何状态写入了顶层聊天变量，那么我们的状态数据就会被 MVU “搭便车”错误地复制到所有开场白的消息楼层变量中。这要求我们必须采用**“战略性延迟写入”**模型，确保我们的首次持久化操作，发生在 MVU 的整个创世流程**完全结束之后**。

---

#### 2.4.1. 历史稀疏性与顶层一致性定律 (Historical Sparsity & Top-Layer Consistency) - [V9.5 修正]

*   **机制**: 虽然 MVU 为了优化性能会主动清理中间历史楼层的变量数据（使其变得**稀疏**），但它通过“重演 (Replay)”机制严格保证了**最新的消息楼层 (Top Layer)** 始终持有完整的、最新的 `stat_data`。
*   **自愈性**: 即使最新的消息楼层被删除，MVU 也会立即计算并将最新的变量状态写入到新的顶层消息中。
*   **核心结论**:
    1.  对于**历史回溯**：历史数据是稀疏的，不可预期的。
    2.  对于**当前状态查询**：最新的消息楼层是**绝对可靠的**事实来源。我们**不需要**也不应该进行复杂的历史倒序查找。直接读取最新一条消息（`getChatMessages(-1)`）的变量数据，即代表了当前的唯一权威状态。

#### 2.5. 核心定律：数据的“两种形态” (The Law of Data Duality)

我们的侦察探针已无可辩驳地证明，MVU 在不同阶段会写入两种不同结构的数据。我们的代码必须能够像说两种方言一样，同时理解这两种形态，才能保证绝对的健壮性。

*   **形态 A：“创世”结构 (Genesis Structure)**
    *   **特征**: 核心数据被包裹在一个名为 `swipes_data` 的数组里。例如：`{ swipes_data: [ { stat_data: ... }, ... ] }`。
    *   **出现时机**: 通常由 MVU 的“创世”流程 (`initCheck`) 在**新聊天首次创建**时写入。
    *   **典型场景**: 当一个角色卡拥有**多个开场白 (swipe)** 时，这种结构允许 MVU 为每一个 swipe 都存储一套独立的初始变量。我们的代码在需要获取特定开-场白的初始状态时，必须解析这种结构。

*   **形态 B：“运行时”结构 (Runtime Structure)**
    *   **特征**: `stat_data` 直接位于数据对象的顶层。例如：`{ stat_data: ..., display_data: ... }`。
    *   **出现时机**:
        1.  在聊天进行中，任何新消息（用户或 AI）产生时。
        2.  在新聊天首次创建，但角色卡**只有一个开场白**时（MVU 似乎会进行优化）。
        3.  **`VARIABLE_UPDATE_ENDED` 事件**的事件载荷。
    *   **典型场景**: 这是 MVU 在日常运行时最常见的数据形态。我们的代码在处理实时更新和回溯历史记录时，主要会遇到它。

*   **核心结论**: `Mvu.getMvuData` 接口在查询第 0 号消息时，**两种结构都有可能返回**。我们的“状态查找器” (`_findLatestAuthoritativeMvuState`) 必须被设计为能够“双语”识别，即先尝试解析“创世”结构，如果失败，则回退到尝试解析“运行时”结构。
