const e=z;console.log('音乐播放器脚本 V-DarkBramblePlayer 确认加载！');const t=performance.now();function n(e,n='log'){const r=`${`(T+${(performance.now()-t).toFixed(0)}ms)`} ${e}`;switch(n){case'warn':console.warn(r);break;case'error':console.error(r);break;case'group':console.group(r);break;case'groupCollapsed':console.groupCollapsed(r);break;case'groupEnd':console.groupEnd();break;default:console.log(r)}}const r=e.z.object({歌名:e.z.string().optional(),歌手:e.z.string().optional(),封面:e.z.string().url({message:'封面URL格式无效'}).optional(),url:e.z.string().url({message:'音轨URL格式无效'})}).strict(),a=e.z.object({variable_path:e.z.string(),greater_than:e.z.number().optional(),greater_than_or_equal_to:e.z.number().optional(),less_than:e.z.number().optional(),less_than_or_equal_to:e.z.number().optional(),value:e.z.union([e.z.string(),e.z.number(),e.z.boolean()]).optional(),value_contains:e.z.string().optional(),time_in_range:e.z.string().regex(/^\d{2}:\d{2}-\d{2}:\d{2}$/,{message:'时间范围格式必须是 "HH:MM-HH:MM"'}).optional()}).strict(),o=e.z.object({type:e.z.literal('mvu_variable'),playlist_id:e.z.string(),priority:e.z.number().default(0),conditions:e.z.array(a).nonempty({message:'触发器必须至少包含一个条件'})}).strict(),i=e.z.object({id:e.z.string(),onFinishRule:e.z.enum(['loop','pop'],{message:'onFinishRule 必须是 \'loop\' 或 \'pop\''}).default('loop'),tracks:e.z.array(r).nonempty({message:'歌单的 \'tracks\' 列表不能为空'})}),l=e.z.object({default_playlist_id:e.z.string().optional(),playlists:e.z.array(i).optional(),triggers:e.z.array(o).optional()}).strict(),s=e.z.object({playlistId:e.z.string(),currentIndex:e.z.number().default(0),playedIndices:e.z.array(e.z.number()).default([]),wasEverPlayed:e.z.boolean().default(!1),triggerSource:o.optional()}),c=e.z.object({active_queue:e.z.array(s),mode:e.z.enum(['list','single','random']).default('list'),volume:e.z.number().min(0).max(1).default(.5),previousMvuState:e.z.record(e.z.string(),e.z.any()).optional()}),u='灰烬双星_MVU状态记忆';function d(e){if(!e||'string'!=typeof e)return null;const t=e.trim().replace('：',':');let r;if(r=t.match(/^(\d{1,2})\s*:\s*(\d{1,2})$/),r){const e=parseInt(r[1],10),t=parseInt(r[2],10);if(e>=0&&e<24&&t>=0&&t<60)return 60*e+t}if(r=t.match(/^(\d{1,2})\s*时\s*(\d{1,2})\s*分?$/),r){const e=parseInt(r[1],10),t=parseInt(r[2],10);if(e>=0&&e<24&&t>=0&&t<60)return 60*e+t}return n(`[TimeParser] 无法解析时间字符串: "${e}"`,'warn'),null}const g=(()=>{n('[MvuManager] 模块正在初始化...');let e={};function t(e,t){if(!t)return!1;for(const n of e.conditions){const e=_.get(t,n.variable_path);let r=!1,a=!1;if(void 0!==n.value_contains)a=!0,'string'==typeof e&&e.includes(n.value_contains)&&(r=!0);else if(void 0!==n.time_in_range){if(a=!0,'string'==typeof e){const t=d(e);if(null!==t){const[e,a]=n.time_in_range.split('-'),o=d(e),i=d(a);null!==o&&null!==i&&(r=o<=i?t>=o&&t<=i:t>=o||t<=i)}}}else void 0!==n.value?(a=!0,e===n.value&&(r=!0)):void 0!==n.greater_than?(a=!0,'number'==typeof e&&e>n.greater_than&&(r=!0)):void 0!==n.greater_than_or_equal_to?(a=!0,'number'==typeof e&&e>=n.greater_than_or_equal_to&&(r=!0)):void 0!==n.less_than?(a=!0,'number'==typeof e&&e<n.less_than&&(r=!0)):void 0!==n.less_than_or_equal_to&&(a=!0,'number'==typeof e&&e<=n.less_than_or_equal_to&&(r=!0));if(!a||!r)return!1}return!0}const r={checkTriggerCondition:t,initialize(){n('[MvuManager] (Lifecycle) 执行 initialize...');try{const t=getVariables({type:'chat'})[u];t&&'object'==typeof t?(e=t,n('[MvuManager] 成功从存档中恢复了 MVU 历史状态。')):(e={},n('[MvuManager] 未发现有效的 MVU 历史存档，已初始化为空状态。','warn'))}catch(t){n(`[MvuManager] 初始化时读取存档失败: ${t}`,'error'),e={}}},resetState(){n('[MvuManager] (Lifecycle) 正在重置模块内部状态...'),e={},n('[MvuManager] 模块状态已重置。')},async persistCurrentState(t){if(C){n('[MvuManager] (Command) 执行 persistCurrentState...'),e=_.cloneDeep(t);try{await updateVariablesWith(t=>(t[u]=e,t),{type:'chat'}),n('[MvuManager] 已成功将当前 MVU 状态持久化。')}catch(e){n(`[MvuManager] 持久化 MVU 状态时发生严重错误: ${e}`,'error')}}else n('[MvuManager] 持久化操作被阻止，因为脚本正在停机。','warn')},getPreviousState:()=>_.cloneDeep(e),calculateChangeReport(e,r,a){const o={newlyActiveTriggers:[],newlyInactiveTriggers:[]};n('[MvuManager] (Query) 正在计算状态变化报告 ("边沿检测")...','group'),n('[Probe] 正在审查用于对比的新旧状态数据:'),console.log('上一份历史记忆 (previousStateData):'),console.dir(_.cloneDeep(e)),console.log('当前权威状态 (currentStateData):'),console.dir(_.cloneDeep(r));for(const i of a){const a=t(i,e),l=t(i,r);!a&&l?(n(`(探針) 新激活的触发器 -> playlist: "${i.playlist_id}"`),o.newlyActiveTriggers.push(i)):a&&!l&&(n(`(探針) 新失效的触发器 -> playlist: "${i.playlist_id}"`),o.newlyInactiveTriggers.push(i))}return n(`报告生成完毕: ${o.newlyActiveTriggers.length} 个新激活, ${o.newlyInactiveTriggers.length} 个新失效。`),n('','groupEnd'),o}};return n('[MvuManager] 模块初始化完成。'),r})(),p=(()=>{n('[StateManager] 模块正在初始化 (优先级队列内核)...');let e=[],t='list',r=.5,a=!1,o=!1;function i(e,t){'number'!=typeof t||t<0||e.playedIndices.add(t)}const l={getPlaybackMode:()=>t,getVolume:()=>r,isPlaying:()=>a,isPerformingEffect:()=>o,getTopQueueItem:()=>_.cloneDeep(e[0]),getQueue:()=>_.cloneDeep(e),getStateSnapshotForRuntime:()=>_.cloneDeep({active_queue:e,mode:t,volume:r,isPlaying:a,isPerformingEffect:o}),getStateSnapshotForPersistence:()=>({active_queue:_.cloneDeep(e).map(e=>({..._.omit(e,['playbackPlan','planIndex','playlistContent']),playedIndices:Array.from(e.playedIndices)})),mode:t,volume:r}),resetState(){n('[StateManager] 正在硬性重置所有状态...','warn'),e=[],t='list',r=.5,a=!1,o=!1},loadState(a){n('[StateManager] 正在加载状态...','group'),t=a.mode,r=a.volume,e=a.active_queue||[],n(`状态加载完成. 队列深度: ${e.length}, 模式: ${t}, 音量: ${r}`),n('','groupEnd')},setPlaybackMode:e=>{t=e},setVolume:e=>{r=e},setPlaying:e=>{a=e},setPerformingEffect:e=>{o=e},updateQueue(t){n(`[StateManager] (Command) updateQueue: 正在更新并重排序队列 (共 ${t.length} 项)...`),e=_.cloneDeep(t).sort((e,t)=>t.priority-e.priority),e.length>0?n(`(探针) 新队首: "${e[0].playlistId}" (优先级: ${e[0].priority})`):n('(探针) 队列现已为空。')},setCurrentIndex(t){const n=e[0];n&&(i(n,n.currentIndex),n.currentIndex=t)},commitNavigationStep(n){const r=e[0];if(r){if(i(r,r.currentIndex),'random'===t&&r.playbackPlan){const e=r.playbackPlan.indexOf(n);-1!==e&&(r.planIndex=e)}r.currentIndex=n}},clearHistoryForCurrentItem(){const t=e[0];t&&t.playedIndices.clear()},resetCurrentItemForLoop(){const t=e[0];t&&(t.playedIndices.clear(),t.currentIndex=0)},commitGenesisState(t,n,r){const a=e[0];a&&(a.currentIndex=t,a.playbackPlan=n,a.planIndex=r)},userInitiatedJump(t){const n=e[0];if(n&&t!==n.currentIndex&&(i(n,n.currentIndex),n.currentIndex=t,'random'===this.getPlaybackMode()&&n.playbackPlan)){const e=n.playbackPlan.indexOf(t);-1!==e&&(n.planIndex=e)}},clearRandomModePlan(){const t=e[0];t&&(t.playbackPlan=void 0,t.planIndex=void 0)},applyNewPlaybackPlan(t,n){const r=e[0];r&&(r.playbackPlan=t,r.planIndex=n)}};return n('[StateManager] 模块初始化完成 (V2.0 内核)。'),l})(),y=(()=>{n('[PlaybackEngine] 模块正在初始化...');let e=null,t=null,r=null,a=null,o=null;function i(e,t,n){return new Promise(r=>{if(o&&(clearInterval(o),o=null),!e)return r();const a=e.volume,i=n/50;if(i<=0)return e.volume=t,r();const l=(t-a)/i;let s=0;o=window.setInterval(()=>{s++,s>=i?(o&&clearInterval(o),o=null,e.volume=t,r()):e.volume+=l},50)})}const l={initialize(){if(e&&t)return;n('[Engine] 正在创建和配置 HTML5 Audio 元素...');const o=()=>{const e=new Audio;return e.preload='auto',e.crossOrigin='anonymous',e.addEventListener('ended',()=>{e===r&&async function(){if(n('[Controller:TrackEnd] === 开始处理轨道自然结束事件 ===','group'),p.isPerformingEffect())return n('[Controller:TrackEnd] 请求被拒绝，因为效果正在执行。','warn'),void n('','groupEnd');const e=p.getTopQueueItem();if(!e)return n('[Controller:TrackEnd] 请求中止：队列为空。'),void n('','groupEnd');try{p.setPerformingEffect(!0),F();const t=v.getCurrentStrategy().onTrackEnd(e),n=await Z(t);n.needsAsyncEffect&&'number'==typeof n.targetIndex&&await q(n.targetIndex)}catch(e){n('[Controller:TrackEnd] 在执行效果时捕获到错误，将启动自愈循环...','error'),console.error(e),await W()}finally{await Y(),await Q('trackEnded'),n('[Controller:TrackEnd] === 轨道结束事件处理完毕 (锁已通过调度器释放) ===','groupEnd')}}()}),e.addEventListener('error',()=>{}),e.addEventListener('timeupdate',L),e};e=o(),t=o(),r=e,a=t,n('[Engine] Audio 元素已就绪。')},getActivePlayer:()=>r,getStandbyPlayer:()=>a,async transitionToTrack(e,t){if(n(`[Engine] 收到过渡请求: URL=${e.slice(0,50)}...`,'group'),!a||!r)throw n('[Engine] 过渡中止：播放器实例尚未初始化。','error'),n('','groupEnd'),new Error('播放器实例尚未初始化');const o=a,l=r;o.src=e,o.load();try{await new Promise((e,t)=>{const r=()=>{o.removeEventListener('canplaythrough',r),o.removeEventListener('error',a),n('[Engine] 备用播放器加载成功 (canplaythrough)。','log'),e()},a=e=>{o.removeEventListener('canplaythrough',r),o.removeEventListener('error',a),n('[Engine] 备用播放器加载失败!','error');const i=e.target.error;t(new Error(`音频加载失败: ${i?.message||'未知错误'}`))};o.addEventListener('canplaythrough',r),o.addEventListener('error',a)})}catch(e){throw n('[Engine] 过渡因加载失败而中止。','groupEnd'),e}await i(l,0,500),l.pause(),[r,a]=[a,r];const s=this.getActivePlayer();if(!s)throw new Error('播放器实例在交换后丢失');const c=s.play();c&&await c,await i(s,t,500),n('[Engine] 过渡成功完成。','groupEnd')},async fadeOutAndPause(){n('[Engine] 命令: FadeOutAndPause'),await i(r,0,400),r?.pause()},async executeHardCut(e,t){n(`[Engine:HardCut] 收到“瞬击”请求: URL=${e.slice(0,50)}...`,'group');const r=this.getActivePlayer();if(!r)throw n('[Engine:HardCut] 致命错误：无可用播放器实例。','error'),n('','groupEnd'),new Error('No active player available for hard cut.');n(`(探针) 切换前 src: ${r.src.slice(-50)}`),r.pause(),r.src=e,r.volume=t,n(`(探针) 切换后 src: ${r.src.slice(-50)}`);try{const e=r.play();e&&await e,p.setPlaying(!0),n('[Engine:HardCut] “瞬击”播放成功。')}catch(e){throw n('[Engine:HardCut] “瞬击”播放失败! 这通常是因为用户未与页面交互。','error'),p.setPlaying(!1),e}finally{n('','groupEnd')}},async resumeAndFadeIn(e){n('[Engine] 命令: ResumeAndFadeIn');const t=r?.play();t&&await t,await i(r,e,400)}};return n('[PlaybackEngine] 模块初始化完成。'),l})();class f{onQueueChanged(e){}advance(e,t){if(n(`[Strategy:List] 收到 advance 请求. 方向: ${t}, 当前: { playlistId: "${e.playlistId}", index: ${e.currentIndex}, rule: "${e.onFinishRule}" }`),'next'===t)return n('[Strategy:List] 决策: advance(next) -> 委托给 onTrackEnd'),this.onTrackEnd(e);const{currentIndex:r,onFinishRule:a,playlistContent:o}=e,i=o.length;if(r>0){const e=r-1;return n(`[Strategy:List] 决策: advance(prev) -> GoTo (index: ${e})`),{action:'GoTo',nextIndex:e}}if('loop'===a){const e=i>0?i-1:0;return n(`[Strategy:List] 决策: advance(prev) at start -> Loop to end (index: ${e})`),{action:'GoTo',nextIndex:e}}return n('[Strategy:List] 决策: advance(prev) at start -> Restart'),{action:'Restart'}}onTrackEnd(e){n(`[Strategy:List] 收到 onTrackEnd 请求. 当前: { playlistId: "${e.playlistId}", index: ${e.currentIndex}, rule: "${e.onFinishRule}" }`);const{currentIndex:t,onFinishRule:r,playlistContent:a,playedIndices:o}=e,i=t+1;if(i<a.length)return n(`[Strategy:List] 决策: onTrackEnd -> GoTo (index: ${i})`),{action:'GoTo',nextIndex:i};if('pop'===r)return n('[Strategy:List] 决策: onTrackEnd at end -> PopStack'),{action:'RemoveTopAndAdvance'};{const e=a.length;return o.size+1>=e?(n('[Strategy:List] 决策: onTrackEnd at end -> LoopReset (一个完整的循环已结束)','warn'),{action:'LoopReset'}):(n('[Strategy:List] 决策: onTrackEnd at end -> GoTo (普通循环，继续播放未听过的歌曲)'),{action:'GoTo',nextIndex:0})}}onPlaybackError(e){return n('[Strategy:List] 收到 onPlaybackError 请求。决策: 委托给 advance(\'next\')'),this.advance(e,'next')}}class m{onQueueChanged(e){}advance(e,t){return n(`[Strategy:Single] 收到 advance 请求. 方向: ${t}. 决策: Restart`),{action:'Restart'}}onTrackEnd(e){return n('[Strategy:Single] 收到 onTrackEnd 请求. 决策: Restart'),{action:'Restart'}}onPlaybackError(e){return n('[Strategy:Single] 收到 onPlaybackError 请求。决策: Stop (单曲循环下无法自动前进)'),{action:'Stop'}}}class I{_generateIntelligentShuffle(e,t,r){n('[Strategy:Random] (Algo) _generateIntelligentShuffle 执行...','groupCollapsed'),n(`输入: allIndices.length=${e.length}, playedIndices.size=${t.size}, currentIndex=${r}`);const a=e.filter(e=>!t.has(e)&&e!==r);n(`计算待选池 (sourceForShuffle) 大小: ${a.length}`);for(let e=a.length-1;e>0;e--){const t=Math.floor(Math.random()*(e+1));[a[e],a[t]]=[a[t],a[e]]}return n(`洗牌完成. 输出 shuffledIndices (纯粹的未来队列): [${a.join(', ')}]`),n('','groupEnd'),a}_generatePlaybackPlan(e,t,r){n('[Strategy:Random] (Algo) _generatePlaybackPlan 执行...','groupCollapsed'),n(`输入: playedIndices.size=${e.size}, currentIndex=${t}, shuffledIndices.length=${r.length}`);const a=Array.from(new Set([...e,t])),o=a.indexOf(t),i=[...a,...r];return n(`(守护者探针) "已知序列" (unique history + current): [${a.join(', ')}]`),n(`生成导航地图 (playbackPlan): [${i.join(', ')}]`),n(`定位导航指针 (planIndex): ${o}`),n('','groupEnd'),{playbackPlan:i,planIndex:o}}_handlePlanEnd(e){return n('[Strategy:Random] (Helper) _handlePlanEnd: 已到达计划终点，开始进行边界决策...','groupCollapsed'),n(`(探针) 待决策歌单: "${e.playlistId}", 结束规则: "${e.onFinishRule}"`),'pop'===e.onFinishRule?(n('(边界决策) onFinishRule 为 \'pop\'，决策 -> PopStack'),n('','groupEnd'),{action:'RemoveTopAndAdvance'}):(n('(边界决策) onFinishRule 为 \'loop\'，决策 -> LoopReset'),n('','groupEnd'),{action:'LoopReset'})}onQueueChanged(e){if(!e)return void n('[Strategy:Random] onQueueChanged 中止：无有效的当前项。');n(`[Strategy:Random] onQueueChanged 已触发 (连续性恢复)，将为歌单 "${e.playlistId}" 生成播放计划...`);const t=e.playlistContent.map((_,e)=>e),r=this._generateIntelligentShuffle(t,e.playedIndices,e.currentIndex),{playbackPlan:a,planIndex:o}=this._generatePlaybackPlan(e.playedIndices,e.currentIndex,r);p.applyNewPlaybackPlan(a,o)}prepareGenesis(e){if(!e||!e.playlistContent)return n('[Strategy:Random] prepareGenesis 中止：传入的队列项无效。','error'),null;n('[Strategy:Random] (Query) prepareGenesis: 收到“创世乐谱”谱写请求...','group');const t=e.playlistContent.map((_,e)=>e);for(let e=t.length-1;e>0;e--){const n=Math.floor(Math.random()*(e+1));[t[e],t[n]]=[t[n],t[e]]}const r=t,a=r[0];return n(`(乐谱) 谱写完成。New CurrentIndex: ${a}, New PlanIndex: 0`),n('','groupEnd'),{newCurrentIndex:a,newPlaybackPlan:r,newPlanIndex:0}}advance(e,t){n(`[Strategy:Random] 收到 advance 请求. 方向: ${t}`,'groupCollapsed');const{playbackPlan:r,planIndex:a}=e;if(!r||void 0===a)return n('[Strategy:Random] 决策中止：导航计划 (playbackPlan) 尚未初始化。','error'),n('','groupEnd'),{action:'DoNothing'};if(n(`(探针) 当前导航指针 (planIndex): ${a}`),n(`(探针) 导航地图 (playbackPlan): [${r.join(', ')}]`),'next'===t){const t=a+1;if(t<r.length){const e=r[t];return n(`[Strategy:Random] 决策: advance(next) -> GoTo (新 planIndex: ${t}, 目标 trackIndex: ${e})`),n('','groupEnd'),{action:'GoTo',nextIndex:e}}return n('[Strategy:Random] advance(next) 已到达计划终点，委托给 _handlePlanEnd...'),n('','groupEnd'),this._handlePlanEnd(e)}{const e=a-1;if(e>=0){const t=r[e];return n(`[Strategy:Random] 决策: advance(prev) -> GoTo (新 planIndex: ${e}, 目标 trackIndex: ${t})`),n('','groupEnd'),{action:'GoTo',nextIndex:t}}return n('[Strategy:Random] 决策: advance(prev) 已在计划起点。返回 DoNothing。'),n('','groupEnd'),{action:'DoNothing'}}}onTrackEnd(e){n('[Strategy:Random] 收到 onTrackEnd 请求.','groupCollapsed');const{playbackPlan:t,planIndex:r}=e;if(!t||void 0===r)return n('[Strategy:Random] 决策中止：导航计划 (playbackPlan) 尚未初始化。返回 Stop 以策安全。','error'),n('','groupEnd'),{action:'Stop'};n(`(探针) 当前导航指针 (planIndex): ${r}`),n(`(探针) 导航地图 (playbackPlan): [${t.join(', ')}]`);const a=r+1;if(a<t.length){const e=t[a];return n(`[Strategy:Random] 决策: onTrackEnd -> GoTo (新 planIndex: ${a}, 目标 trackIndex: ${e})`),n('','groupEnd'),{action:'GoTo',nextIndex:e}}return n('[Strategy:Random] onTrackEnd 已到达计划终点，委托给 _handlePlanEnd...'),n('','groupEnd'),this._handlePlanEnd(e)}onPlaybackError(e){return n('[Strategy:Random] 收到 onPlaybackError 请求。决策: 委托给 advance(\'next\')'),this.advance(e,'next')}}const v=(()=>{n('[StrategyManager] 模块正在初始化...');const e={list:new f,single:new m,random:new I};let t=e.list;const r={setMode(r){n(`[StrategyManager] (Command) setMode: 切换策略模式为 -> ${r}`),t=e[r]},getCurrentStrategy:()=>t,notifyQueueChanged(){n(`[StrategyManager] (Command) notifyQueueChanged: 正在通知当前策略 (${t.constructor.name}) 队列已变更...`,'groupCollapsed');const e=p.getTopQueueItem();t.onQueueChanged(e),n('[StrategyManager] 通知完成。','groupEnd')}};return n('[StrategyManager] 模块初始化完成。'),r})(),h='余烬双星_播放器状态';let E=!1,P=!1,w=null,S=null,C=!0,x={},M=[],b='',T=!1,k=!1,R=null;const A=[],D=[];async function V(e,t){if(P)n('[Reconciler] 请求被合并：前一个校准任务仍在进行中。','warn');else{P=!0,n('=== [Reconciler] “统一校准官”已接管运行时事件 ===','group');try{p.setPerformingEffect(!0),n('[Reconciler] (事务) 已上效果锁并广播“过渡中”状态，UI应进入等待。'),F();try{const r=p.getTopQueueItem(),a=e?.stat_data?e.stat_data:(await U())?.mvuData?.stat_data??{};n(`[Reconciler] (探针) 已确定本次校准的权威 MVU 状态 (来源: ${e?'事件载荷':'主动查询'})。`);const o=g.getPreviousState(),i=g.calculateChangeReport(o,a,M),l=p.getQueue();if(i.newlyInactiveTriggers.length>0&&(_.remove(l,e=>i.newlyInactiveTriggers.some(t=>G(e.triggerSource,t))),n(`[Reconciler] (修改) 根据报告移除了 ${i.newlyInactiveTriggers.length} 个失效项。`)),i.newlyActiveTriggers.length>0)for(const e of i.newlyActiveTriggers){if(l.some(t=>t.triggerSource&&G(t.triggerSource,e))){n(`[Reconciler] (防御) 拒绝添加重复的激活项: "${e.playlist_id}"`,'warn');continue}const t=O({type:'mvu',playlistId:e.playlist_id,trigger:e});t&&(l.push(t),n(`[Reconciler] (修改) 根据报告添加了新激活项: "${t.playlistId}"`))}p.updateQueue(l);const s=p.getTopQueueItem();if(s?.playlistId!==r?.playlistId){if(n(`[Reconciler] (决策) 队首发生变更！ 从 "${r?.playlistId??'无'}" 变为 "${s?.playlistId??'无'}"。`),s){n('[Reconciler] (握手) 正在通知 StrategyManager 队列已变更...'),v.notifyQueueChanged(),s.wasEverPlayed=!0;const e=s.wasEverPlayed?s.currentIndex:0;if(p.isPlaying())n('[Reconciler] (效果) 用户正在播放，将执行过渡效果...'),'hard'===t?.transitionEffect?await y.executeHardCut(s.playlistContent[e].url,p.getVolume()):await q(e);else{n('[Reconciler] (效果) 用户已暂停，仅在后台静默更新轨道，不播放。');const t=s.playlistContent[e],r=y.getActivePlayer();t&&r&&(r.src=t.url)}}}else n('[Reconciler] (决策) 队首未发生变更，保持当前播放稳定。');await g.persistCurrentState(a)}catch(e){n(`[Reconciler] 核心逻辑执行期间发生严重错误: ${e}`,'error'),console.error(e)}finally{await Q('reconciliation')}}finally{P=!1,await Y(),n('=== [Reconciler] “统一校准官”任务完成 (锁已通过调度器释放) ===','groupEnd')}}}function F(){const e=p.getTopQueueItem(),t=e?.playlistContent??[],r=e?.currentIndex??0,a={currentItem:t[r]?{title:t[r].歌名,artist:t[r].歌手,cover:t[r].封面}:null,isPlaying:p.isPlaying(),playbackMode:p.getPlaybackMode(),masterVolume:p.getVolume(),playlist:t.map(e=>({title:e.歌名,artist:e.歌手,cover:e.封面})),isTransitioning:p.isPerformingEffect()};n(`[Broadcast] 正在广播完整状态... isPlaying: ${a.isPlaying}, mode: ${a.playbackMode}, currentItem: ${a.currentItem?.title??'无'}`,'groupCollapsed'),n(`详细: isTransitioning=${a.isTransitioning}`),n('','groupEnd'),A.forEach(e=>{try{e(a)}catch(e){console.error('[音乐脚本] 完整状态回调执行出错:',e)}})}function L(){const e=y.getActivePlayer();if(!p.isPlaying()||!e)return;const t={currentTime:e.currentTime,duration:e.duration||0};D.forEach(e=>e(t))}async function Q(e){if(C)try{n(`[State] 由 "${e}" 触发状态写入...`);const t=p.getStateSnapshotForPersistence();await updateVariablesWith(e=>(e[h]=t,e),{type:'chat'}),n('[State] 状态已成功写入酒馆变量')}catch(e){n(`[State] 写入状态时发生严重错误: ${e}`,'error')}else n(`[State] 写入操作被阻止，因为脚本正在停机。(来源: ${e})`,'warn')}function H(e){const t=e.issues[0],r=t.path.join(' -> '),a=t.message,o=`路径: ${r} | 问题: ${a}`;n(`[ZodValidator] 世界书配置验证失败: ${`[MusicConfig] 内容错误:\n路径: ${r}\n问题: ${a}`}`,'error'),toastr.error(o,'[MusicConfig] 内容错误',{timeOut:15e3})}function G(e,t){if(!e||!t)return e===t;if(e.playlist_id!==t.playlist_id)return!1;const n=e=>Object.keys(e).sort().map(t=>`${t}:${String(e[t])}`).join(','),r=e.conditions.map(n).sort(),a=t.conditions.map(n).sort();return r.length===a.length&&r.every((e,t)=>e===a[t])}async function U(e){if(e&&0===e.messageId&&'number'==typeof e.swipeId){n(`[StateFinder] (精确制导模式) 目标: message_id=${e.messageId}, swipe_id=${e.swipeId}`,'groupCollapsed');try{const t=await Mvu.getMvuData({type:'message',message_id:0}),r=t?.swipes_data?.[e.swipeId];if(r?.stat_data)return n('[StateFinder] (探针) 检测到“创世”结构 (swipes_data)，成功命中！'),n('','groupEnd'),{mvuData:r,messageId:0};if(t?.stat_data)return n('[StateFinder] (探针) 检测到“运行时”结构 (顶层 stat_data)，直接采用。'),n('','groupEnd'),{mvuData:t,messageId:0};n('[StateFinder] (精确制导模式) 查找失败：在两种已知结构中均未找到 stat_data。','warn')}catch(e){n(`[StateFinder] (精确制导模式) 查询时出错: ${e}`,'error')}finally{n('','groupEnd')}}n('[StateFinder] (回溯扫描模式) 开始执行...','groupCollapsed');try{const e=getChatMessages(-1,{include_swipes:!0});for(let t=e.length-1;t>=0;t--){const r=e[t].message_id;if('number'==typeof r)try{n(`(探针) 正在查询 message_id: ${r}...`);const e=await Mvu.getMvuData({type:'message',message_id:r});if(e?.stat_data)return n(`[StateFinder] 查找成功！在 message_id: ${r} 处找到权威状态。`),n('','groupEnd'),{mvuData:e,messageId:r}}catch(e){n(`(探针) 查询 message_id: ${r} 时接口失败，将继续向前查找。错误: ${e}`,'warn')}else n(`(探针) 跳过无效楼层 (索引 ${t})，因其 message_id 为 ${r}。`,'warn')}return n('[StateFinder] 查找失败：遍历完所有消息楼层，均未找到有效的 stat_data。','warn'),null}catch(e){return n(`[StateFinder] 在获取聊天记录时发生严重错误: ${e}`,'error'),null}finally{n('','groupEnd')}}async function N(){n('[WorldbookParser V3-聚合模式] 开始解析...','group');const e={playlists:[],triggers:[],defaultPlaylistId:void 0,_defaultPlaylistIdSourceFile:null};try{const t=getCharWorldbookNames('current'),r=[t.primary,...t.additional].filter(Boolean);let a=!1;for(const t of r){if(!t)continue;const r=(await getWorldbook(t)).filter(e=>e.name.includes('[MusicConfig]'));r.length>0&&(a=!0);for(const t of r){n(`[Parser V3] 发现并处理配置文件: "${t.name}"`);try{const r=YAML.parse(t.content),a=l.safeParse(r);if(!a.success){n(`[Parser V3] 条目 "${t.name}" Zod验证失败，已跳过。`,'error'),H(a.error);continue}const o=a.data;if(o.playlists&&e.playlists.push(...o.playlists.map(e=>({...e,_sourceFile:t.name}))),o.triggers&&e.triggers.push(...o.triggers.map(e=>({...e,_sourceFile:t.name}))),o.default_playlist_id){if(e.defaultPlaylistId&&e.defaultPlaylistId!==o.default_playlist_id){const r=`在文件 "${t.name}" 中发现的 default_playlist_id ("${o.default_playlist_id}") 覆盖了来自文件 "${e._defaultPlaylistIdSourceFile??'未知'}" 的定义 ("${e.defaultPlaylistId}")。为确保行为可预测，建议只保留一个定义。`;n(`[Parser V3] ${r}`,'warn'),toastr.warning(r,'配置警告',{timeOut:2e4,closeButton:!0})}e.defaultPlaylistId=o.default_playlist_id,e._defaultPlaylistIdSourceFile=t.name}}catch(e){n(`[Parser V3] 解析条目 "${t.name}" 时发生YAML语法错误: ${e.message}`,'error'),toastr.error(`[MusicConfig] 文件 "${t.name}" 格式错误：YAML 语法不正确。`,'配置错误',{timeOut:1e4})}}}if(!a)return n('[Parser V3] 未在任何世界书中找到 [MusicConfig] 条目。','warn'),n('','groupEnd'),null;n('[Parser V3] 所有文件聚合完毕，开始执行全局健全性检查...','groupCollapsed');let o=!0;const i=_.groupBy(e.playlists,'id');for(const e in i)if(i[e].length>1){const t=`[MusicConfig] 致命错误: 歌单 ID "${e}" 在多个文件中重复定义。来源: ${i[e].map(e=>e._sourceFile).join(', ')}。ID 必须是唯一的。`;n(t,'error'),toastr.error(t,'配置冲突',{timeOut:15e3}),o=!1}const s=new Set(e.playlists.map(e=>e.id));if(e.defaultPlaylistId&&!s.has(e.defaultPlaylistId)){const t=`[MusicConfig] 配置错误: 最终的 default_playlist_id ("${e.defaultPlaylistId}", 来自文件 "${e._defaultPlaylistIdSourceFile??'未知'}") 指向了一个不存在的歌单。`;n(t,'error'),toastr.error(t,'配置错误',{timeOut:15e3}),e.defaultPlaylistId=void 0}const c=e.triggers.filter(e=>{if(s.has(e.playlist_id))return!0;const t=`[MusicConfig] 校验失败: 来自文件 "${e._sourceFile}" 的触发器指向了不存在的歌单ID "${e.playlist_id}"。该触发器将被忽略。`;return n(t,'error'),toastr.error(t,'配置错误',{timeOut:1e4}),!1});if(!o)return n('[Parser V3] 全局健全性检查失败，配置被拒绝。','error'),n('','groupEnd'),n('','groupEnd'),null;if(n('[Parser V3] 全局健全性检查通过。'),n('','groupEnd'),0===e.playlists.length){const e='[MusicConfig] 致命错误: 所有配置文件中都未能找到任何有效的歌单 (playlists)。播放器无法加载。';return n(e,'error'),toastr.error(e,'配置错误',{timeOut:15e3}),n('','groupEnd'),null}const u={};for(const t of e.playlists){const e=t.tracks.map(e=>({url:e.url,歌名:e.歌名&&''!==e.歌名.trim()?e.歌名:decodeURIComponent(e.url.split('/').pop()?.split('?')[0]||'未知歌曲'),歌手:e.歌手,封面:e.封面}));u[t.id]={..._.omit(t,'_sourceFile'),tracks:e}}const d={playlists:u,defaultId:e.defaultPlaylistId,triggers:c.map(e=>_.omit(e,'_sourceFile'))};return n('[Parser V3] 数据归一化完成，运行时配置已就绪。','log'),n('','groupEnd'),d}catch(e){return n(`[Parser V3] 解析过程中发生意外顶层错误: ${e}`,'error'),toastr.error('音乐配置加载时发生未知错误，请检查控制台日志。'),n('','groupEnd'),null}}function j(e,t){return{playlistId:e.playlistId,priority:e.triggerSource?.priority??-1/0,playlistContent:_.cloneDeep(t.tracks),onFinishRule:t.onFinishRule,currentIndex:e.currentIndex,playedIndices:new Set(e.playedIndices),wasEverPlayed:e.wasEverPlayed,triggeredBy:e.triggerSource?'mvu':'base',triggerSource:e.triggerSource}}function O(e){const{playlistId:t}=e;if(!t||!x[t])return n(`[Factory] 创建队列项失败：请求的歌单ID "${t}" 不存在。`,'error'),null;const r=x[t],a={playlistId:t,playlistContent:_.cloneDeep(r.tracks),currentIndex:0,playedIndices:new Set,wasEverPlayed:!1};return'base'===e.type?{...a,priority:-1/0,triggeredBy:'base',onFinishRule:'loop'}:{...a,priority:e.trigger.priority,triggeredBy:'mvu',onFinishRule:r.onFinishRule,triggerSource:e.trigger}}async function B(e,t,r){n('=== 开始执行【核心·自愈式初始化】 V9.0 ===','group');try{k=!0,p.resetState(),g.resetState(),g.initialize();const a=y.getActivePlayer();if(a&&a.pause(),M=[],x={},b='',!e)throw n('[Initializer] 配置无效，初始化中止。','error'),F(),new Error('世界书音乐配置解析失败，请检查配置。');x=e.playlists,b=e.defaultId,M=e.triggers;const o=function(){n('[StateReader] 正在尝试从酒馆变量读取持久化状态...');const e=getVariables({type:'chat'})[h];if(!e||'object'!=typeof e)return n('[StateReader] 未发现有效存档。'),null;n('[StateReader] 发现原始状态数据，正在提交给 Zod 进行安全验证...');const t=c.safeParse(e);return t.success?(n('[StateReader] Zod 验证成功，状态数据安全。'),t.data):(console.warn('[StateReader] 持久化状态验证失败:',t.error),null)}(),i=t?.mvuData?.stat_data??null,l=t?.messageId;let s=[],u=b;const d=getChatMessages(0,{include_swipes:!0})[0];if(d){const e=d.swipes?.[d.swipe_id],t=e?.match(/<playlist:([^>]+)>/);if(t&&t[1]){const e=t[1];if(x[e])n(`[Initializer-Heal] (基准) 从开场白标签确定权威基础歌单: "${e}"`),u=e;else{const t=`[MusicConfig] 配置警告: 开场白标签 <playlist:${e}> 指向了一个不存在的歌单ID。将回退至默认歌单。`;n(t,'warn'),toastr.warning(t,'配置警告',{timeOut:15e3})}}else n(`[Initializer-Heal] (基准) 开场白无标签，使用世界书默认歌单: "${b??'无'}"`)}if(u){if(new Set(M.map(e=>e.playlist_id)).has(u)){const e=`[MusicConfig] 致命配置错误: 歌单 "${u}" 不能同时被用作基础歌单（在开场白或默认设置中）和场景歌单（被触发器关联）。请为它们使用不同的歌单。`;throw n(e,'error'),toastr.error(e,'配置冲突',{timeOut:2e4,closeButton:!0}),new Error('基础歌单与场景歌单存在致命冲突。')}}if(o){n('[Initializer-Heal] (净化) 开始审查存档...','groupCollapsed');const e=[];for(const t of o.active_queue){if(!Object.prototype.hasOwnProperty.call(x,t.playlistId)){n(`(净化-丢弃) 存档歌单 "${t.playlistId}" 已不存在。`,'warn');continue}const r=x[t.playlistId];if(!t.triggerSource)t.playlistId===u?(n(`(净化-保留) 基础歌单 "${t.playlistId}" 仍然有效。`),e.push(j(t,r))):n(`(净化-丢弃) 基础歌单 "${t.playlistId}" 已被新的权威歌单 "${u??'无'}" 替代。`,'warn');else{const a=M.find(e=>e.playlist_id===t.playlistId);if(n(`(探针-净化) 正在审查存档的MVU歌单 "${t.playlistId}"...`),'pop'===r.onFinishRule){n('(净化-丢弃) 原因：规则为 \'pop\'。');continue}if(!a){n('(净化-丢弃) 原因：在最新的世界书配置中已找不到对应的触发器。','warn');continue}if(!g.checkTriggerCondition(a,i)){n('(净化-丢-弃) 原因：最新的触发器条件在当前状态下不满足。');continue}n('(净化-保留) 验证通过。'),e.push(j(t,r))}}s=e,n('[Initializer-Heal] (净化) 审查完成。','groupEnd')}if(i&&M.length>0){n('[Initializer-Heal] (补充) 正在检查是否有新激活的场景歌单...','groupCollapsed');for(const e of M){if(!s.some(t=>t.triggerSource&&G(t.triggerSource,e))&&g.checkTriggerCondition(e,i)){const t=x[e.playlist_id];if(t&&'pop'===t.onFinishRule)if(0===l){n(`(补充) 允许添加 'pop' 歌单 "${e.playlist_id}"，因为上下文是开场白。`);const t=O({type:'mvu',playlistId:e.playlist_id,trigger:e});t&&s.push(t)}else n(`(补充-阻止) 场景歌单 "${e.playlist_id}" 因规则为 'pop' 且上下文非开场白而被忽略。`,'warn');else{const t=O({type:'mvu',playlistId:e.playlist_id,trigger:e});t&&s.push(t)}}}n('[Initializer-Heal] (补充) 检查完成。','groupEnd')}if(!s.some(e=>'base'===e.triggeredBy)&&u&&x[u]){n(`[Initializer-Heal] (注入) 最终注入权威基础歌单 "${u}"。`);const e=O({type:'base',playlistId:u});e&&s.push(e)}n('[Initializer-Finalize] 正在提交最终队列并完成设置...'),p.updateQueue(s);const f=o?.mode??'list';p.setPlaybackMode(f),v.setMode(f),n(`(探针) 策略模式已同步为: ${f}`),v.notifyQueueChanged(),y.initialize();const m=o?.volume??.5;p.setVolume(m),y.getActivePlayer()&&(y.getActivePlayer().volume=m),y.getStandbyPlayer()&&(y.getStandbyPlayer().volume=0);const I=p.getTopQueueItem();if(I){const e=I.playlistContent[I.currentIndex];e&&y.getActivePlayer()&&(y.getActivePlayer().src=e.url)}if(i?(await g.persistCurrentState(i),n('[Initializer-Finalize]  已将本次创世的权威MVU状态持久化为历史基准。')):(await g.persistCurrentState({}),n('[Initializer-Finalize] 当前无MVU状态，已将空状态持久化为历史基准。')),await Q('initialization'),F(),r?.autoPlayIfWasPlaying){n('[Initializer] (探针) 检测到来自开场白滑动的“自动播放”意图。','warn');p.getTopQueueItem()?(n('[Initializer] 新的开场白已配置歌单，将执行“创世播放”...'),await async function(){if(p.isPerformingEffect())return void n('[Controller:Genesis] 请求被拒绝，因为效果正在执行。','warn');const e=p.getTopQueueItem();if(!e)return void n('[Controller:Genesis] 请求中止：播放列表为空。');try{p.setPerformingEffect(!0),n(`[Controller:Genesis] === “创世播放”效果开始 (目标索引: ${e.currentIndex}) ===`,'group'),p.setPlaying(!0),F(),await q(e.currentIndex)}catch(e){n(`[Controller:Genesis] “创世播放”效果执行时发生意外顶层错误: ${e}`,'error'),p.setPlaying(!1),F()}finally{await Y(),await Q('genesisPlay'),n('[Controller:Genesis] === “创世播放”效果结束 (锁已通过调度器释放) ===','groupEnd')}}()):n('[Initializer] 新的开场白未配置歌单，自动播放已取消。')}}catch(e){throw n(`[Initializer] 核心初始化过程中发生严重错误: ${e}`,'error'),console.error(e),e}finally{n('=== 【核心·自愈式初始化】执行完毕 ===','groupEnd')}}async function q(e){n(`[Executor] 收到播放指令，目标索引: ${e}`,'group');const t=p.getTopQueueItem();if(!t)return n('[Executor] 执行中止：无有效队列项','warn'),n('','groupEnd'),Promise.resolve();const r=t.playlistContent[e];if(!r?.url)throw n(`[Executor] 执行失败：在索引 ${e} 处找不到音轨或音轨URL无效。`,'error'),n('','groupEnd'),new Error(`Invalid track at index ${e}`);try{await y.transitionToTrack(r.url,p.getVolume()),p.setPlaying(!0),function(){const e=p.getTopQueueItem(),t=y.getStandbyPlayer();if(!t||!e)return;const n=e.currentIndex+1;if(n<e.playlistContent.length){const r=e.playlistContent[n];r&&t.src!==r.url&&(t.src=r.url,t.load())}}(),n(`[Executor] 索引 ${e} 播放成功。`)}catch(e){throw n(`[Executor] PlaybackEngine报告播放失败。原因: ${e}`,'error'),e}finally{n('','groupEnd')}}async function W(){n('[SelfHeal] 启动“迭代式自愈循环”... 播放器进入紧急自愈模式。','warn');let e=1;const t=p.getTopQueueItem(),r=t?.playlistContent.length??0;for(t&&toastr.error(`歌曲《${t.playlistContent[t.currentIndex]?.歌名??'未知歌曲'}》加载失败，正在尝试自动处理...`);;){if(r>0&&e>=r)return n(`[SelfHeal] (熔断器) 连续失败 ${e} 次，已达到或超过阈值 ${r}。自愈中止。`,'error'),t&&toastr.error(`歌单《${t.playlistId}》中所有歌曲均无法加载，播放已停止。`),p.setPlaying(!1),void F();const a=p.getTopQueueItem();if(!a)return n('[SelfHeal] 自愈中止：中途队列变空。','warn'),p.setPlaying(!1),void F();const o=v.getCurrentStrategy().onPlaybackError(a);n(`[SelfHeal] 收到策略 (${v.getCurrentStrategy().constructor.name}) 的错误决策: { action: '${o.action}' }`);const i=await Z(o);if(!i.needsAsyncEffect)return void n('[SelfHeal] 决策应用后无需播放，自愈中止。');if('number'!=typeof i.targetIndex)return n('[SelfHeal] 决策应用后需要播放，但没有有效的 targetIndex。自愈中止。','error'),p.setPlaying(!1),void F();try{return await q(i.targetIndex),n('[SelfHeal] 播放成功，自愈循环结束。','log'),void F()}catch(t){e++;const r=p.getTopQueueItem(),a=r?.playlistContent[r.currentIndex]?.歌名??'未知歌曲';n(`[SelfHeal] 第 ${e} 次播放失败:`,'error'),console.error(t),toastr.error(`下一首《${a}》加载失败...`)}}}async function Z(e){n(`[CentralCommand] 正在应用策略决策: { action: '${e.action}', nextIndex: ${e.nextIndex??'N/A'} }`,'group');let t,r=!1;const a=p.getTopQueueItem();switch(e.action){case'GoTo':'number'==typeof e.nextIndex?(n('[CentralCommand] 指令: GoTo。提交导航步骤...'),p.commitNavigationStep(e.nextIndex),r=!0,t=e.nextIndex):(n('[CentralCommand] 致命逻辑错误: GoTo 指令缺少 nextIndex！这是一个策略模块的BUG。','error'),console.error('探针捕获：错误的决策对象:',e),console.error('探针捕获：发生错误时的播放器状态:',p.getStateSnapshotForRuntime()),r=!1);break;case'Restart':n('[CentralCommand] 指令: Restart。请求从头重播当前轨道。'),a&&(n('[CentralCommand] (探针) 此决策不改变状态索引，仅生成一个效果指令。'),r=!0,t=a.currentIndex);break;case'RemoveTopAndAdvance':{n('[CentralCommand] 指令: RemoveTopAndAdvance。正在执行【自洽式】队列修改与过渡...');const e=p.getQueue(),a=e.shift();n(`(探针) 已从队列中移除: "${a?.playlistId}"`),p.updateQueue(e),n('[CentralCommand] (握手) 正在通知 StrategyManager 队列已变更...'),v.notifyQueueChanged();const o=p.getTopQueueItem();o?(n(`(决策) 新队首为 "${o.playlistId}"，准备过渡到其当前索引: ${o.currentIndex}`),r=!0,t=o.currentIndex):(n('(决策) 队列已空，停止播放。'),p.setPlaying(!1),r=!1);break}case'LoopReset':{n('[CentralCommand] 指令: LoopReset。执行“指挥家模型”...','warn'),p.resetCurrentItemForLoop();if('random'===p.getPlaybackMode()){n('(指挥) 检测到随机模式，向作曲家索要新乐谱...');const e=v.getCurrentStrategy().prepareGenesis(p.getTopQueueItem());e&&p.commitGenesisState(e.newCurrentIndex,e.newPlaybackPlan,e.newPlanIndex)}const e=p.getTopQueueItem()?.currentIndex??0;n(`(指挥) 流程完成。最终确定的新起始索引为: ${e}`),r=!0,t=e;break}case'Stop':n('[CentralCommand] 指令: Stop。停止播放。'),p.setPlaying(!1);break;default:n('[CentralCommand] 指令: DoNothing。无状态变更。')}'RemoveTopAndAdvance'!==e.action&&F();const o={needsAsyncEffect:r,targetIndex:t};return n(`[CentralCommand] 决策应用完成。返回指令: { needsAsyncEffect: ${o.needsAsyncEffect}, targetIndex: ${o.targetIndex??'N/A'} }`),n('','groupEnd'),o}async function Y(){n('[LockManager] 正在释放效果锁并广播最终状态...'),p.setPerformingEffect(!1),F()}async function J(e){if(n(`[Controller:Nav] === 开始处理用户导航事件 (方向: ${e}) ===`,'group'),p.isPerformingEffect())return n('[Controller:Nav] 请求被拒绝，因为效果正在执行。','warn'),void n('','groupEnd');const t=p.getTopQueueItem();if(!t)return n('[Controller:Nav] 请求中止：队列为空。'),void n('','groupEnd');try{p.setPerformingEffect(!0),F();const r=v.getCurrentStrategy().advance(t,e),a=await Z(r);if(n(`[Controller:Nav] (探针) 原始决策: ${r.action}, 处理指令: needsAsyncEffect=${a.needsAsyncEffect}`),'Restart'===r.action){n('[Controller:Nav] 检测到 Restart 决策，执行 seek(0) 效果。');const e=y.getActivePlayer();e&&(e.currentTime=0),'single'!==p.getPlaybackMode()&&toastr.info('已是第一首')}else a.needsAsyncEffect&&'number'==typeof a.targetIndex?await q(a.targetIndex):'DoNothing'===r.action&&toastr.info('next'===e?'已是歌单最后一首。':'已是歌单第一首。')}catch(e){n('[Controller:Nav] 在执行效果时捕获到错误，将启动自愈循环...','error'),console.error(e),await W()}finally{await Y(),await Q('navigation'),n('[Controller:Nav] === 用户导航事件处理完毕 (锁已通过调度器释放) ===','groupEnd')}}function K(){window.musicPlayerAPI={requestInitialization:()=>E?(n('[API] requestInitialization (已完成): 一个迟到的界面发来请求，立即返回成功契约。'),F(),Promise.resolve()):(S?n('[API] requestInitialization (后续): 又一个界面请求到达，返回【已存在的】共享契约。'):(n('[API] requestInitialization (首次): 第一个界面请求到达，正在创建【共享的】Promise契约...'),S=new Promise((e,t)=>{w={resolve:e,reject:t}})),S),togglePlayPause:()=>async function(){if(n('[Controller:Toggle] === 开始处理播放/暂停切换事件 ===','group'),p.isPerformingEffect())return n('[Controller:Toggle] 请求被拒绝，因为效果正在执行。','warn'),void n('','groupEnd');const e=p.getTopQueueItem();if(!e)return n('[Controller:Toggle] 请求中止：播放列表为空。'),toastr.info('播放列表为空'),void n('','groupEnd');try{let t;p.setPerformingEffect(!0),F();const n=y.getActivePlayer(),r=e.currentIndex,a=n?.src,o=e.playlistContent[r]?.url;switch(t=p.isPlaying()?{action:'pause'}:n&&a===o&&n.currentTime>0?{action:'resume'}:{action:'playNew',targetIndex:r},'pause'!==t.action?p.setPlaying(!0):p.setPlaying(!1),F(),t.action){case'pause':await y.fadeOutAndPause();break;case'resume':await y.resumeAndFadeIn(p.getVolume());break;case'playNew':'number'==typeof t.targetIndex&&await q(t.targetIndex)}}catch(e){n('[Controller:Toggle] 在执行效果时捕获到错误，将启动自愈循环...','error'),console.error(e),await W()}finally{await Y(),await Q('togglePlayPause'),n('[Controller:Toggle] === 播放/暂停切换事件处理完毕 (锁已通过调度器释放) ===','groupEnd')}}(),playNext:()=>{J('next')},playPrev:()=>{J('prev')},playIndex:e=>{const t=p.getTopQueueItem();t&&e>=0&&e<t.playlistContent.length&&async function(e){if(n(`[Controller:PlayIndex] === 开始处理索引播放事件 (目标: ${e}) ===`,'group'),p.isPerformingEffect())return n('[Controller:PlayIndex] 请求被拒绝，因为效果正在执行。','warn'),void n('','groupEnd');try{p.setPerformingEffect(!0),F();const t=p.getTopQueueItem(),r=p.getPlaybackMode();if(t&&e===t.currentIndex){n('[Controller:PlayIndex] (决策) 用户点击了当前歌曲，将从头重播。');const e=y.getActivePlayer();e&&(e.currentTime=0)}else'list'===r||'single'===r?(n(`[Controller:PlayIndex] (决策) ${r} 模式，执行标准跳转...`),p.setCurrentIndex(e),await q(e)):'random'===r&&(n('[Controller:PlayIndex] (决策) random 模式，执行“用户跳转”高级逻辑...'),p.userInitiatedJump(e),await q(e))}catch(e){n('[Controller:PlayIndex] 在执行效果时捕获到错误，将启动自愈循环...','error'),console.error(e),await W()}finally{await Y(),await Q('playIndex'),n('[Controller:PlayIndex] === 索引播放事件处理完毕 (锁已通过调度器释放) ===','groupEnd')}}(e)},persistVolumeAndBroadcast:e=>{const t=Math.max(0,Math.min(1,e)),n=y.getActivePlayer();p.setVolume(t),n&&!p.isPerformingEffect()&&(n.volume=t),Q('persistVolume'),F()},setLiveVolume:e=>{const t=y.getActivePlayer();t&&!p.isPerformingEffect()&&(t.volume=Math.max(0,Math.min(1,e)))},setPlaybackMode:e=>{n(`=== 开始执行【模式切换】事务 (请求: ${e}) ===`,'group');const t=p.getPlaybackMode();if(e===t)return n(`[ModeSwitch] 模式未变更 (仍为 ${e})，事务提前中止。`),void n('','groupEnd');p.setPlaybackMode(e),v.setMode(e),n(`[ModeSwitch] 策略已切换为: ${v.getCurrentStrategy().constructor.name}`),'random'===t&&(n('[ModeSwitch] 正在为旧模式 "random" 执行“离开”生命周期钩子...'),p.clearRandomModePlan()),'random'===e&&(n('[ModeSwitch] 正在为新模式 "random" 执行“进入”生命周期钩子...'),v.notifyQueueChanged()),Q('setPlaybackMode'),F(),n('=== 【模式切换】事务执行完毕 ===','groupEnd')},seekTo:e=>{const t=y.getActivePlayer();t?.duration&&(t.currentTime=t.duration*e)},getCurrentState:()=>{const e=p.getTopQueueItem(),t=e?.playlistContent??[],r=e?.currentIndex??0,a={currentItem:t[r]?{title:t[r].歌名,artist:t[r].歌手,cover:t[r].封面}:null,isPlaying:p.isPlaying(),playbackMode:p.getPlaybackMode(),masterVolume:p.getVolume(),playlist:t.map(e=>({title:e.歌名,artist:e.歌手,cover:e.封面})),isTransitioning:p.isPerformingEffect()};return n('[探针 B] 前端主动调用 getCurrentState 获取初始状态，后台返回的数据如下:','warn'),console.dir(a),a},onFullStateUpdate:e=>{'function'==typeof e&&A.push(e)},onTimeUpdate:e=>{'function'==typeof e&&D.push(e)}},initializeGlobal('musicPlayerAPI',window.musicPlayerAPI)}async function X(){if(E)return;const e=SillyTavern.getCurrentChatId?SillyTavern.getCurrentChatId():null;if(SillyTavern.chat.length>0&&null!==e){E=!0,R=e,n(`【初始化指挥官 V9.8】锁定ID: ${R}，开始执行“分流-等待-执行”协议...`,'group');try{const e=await N();if(!e)throw new Error('无法解析世界书配置，初始化中止。');const t=e.triggers&&Array.isArray(e.triggers)&&e.triggers.length>0;if(n(`(探针-决策) 作者意图判断 -> 是MVU卡吗? ${t}`),t){n('【指挥官】(路径选择) 检测到MVU卡，进入“安全路径”，开始等待MVU就绪...');if(!await async function(){n('【安全观察哨】已上岗，开始执行MVU就绪检查...','group');try{await waitGlobalInitialized('Mvu'),n('【观察哨】(探针) 阶段一成功：MVU 框架已加载。')}catch(e){return n(`【观察哨】(探针) 阶段一失败: ${e}。`,'warn'),n('【安全观察哨】任务失败。','groupEnd'),!1}const e=1e4,t=250,r=Date.now();let a=!1;n('【观察哨】(探针) 阶段二开始：正在严密监视 message_id: 0 的创世数据...');for(;Date.now()-r<e;){try{const e=await Mvu.getMvuData({type:'message',message_id:0});if(e&&(e.swipes_data||e.stat_data)){n('【观察哨】(探针) 阶段二成功：在消息楼层中确认到创世数据！'),a=!0;break}}catch(e){}await new Promise(e=>setTimeout(e,t))}if(!a)return n('【观察哨】(探针) 阶段二失败：观察超时！','error'),n('【安全观察哨】任务失败。','groupEnd'),!1;n('【观察哨】(探针) 阶段三开始：执行MVU集成激活序列...');try{return function(){n('[EventDispatcher] 正在注册【运行时】MVU 事件监听器...');const e=e=>t=>{T&&k?(n(`[Event] 捕获到MVU事件: ${e}，即将唤醒校准官...`),V(t)):n(`[Gatekeeper] 捕获到MVU事件 (${e})，但系统未就绪，已忽略。`,'warn')};eventOn(Mvu.events.VARIABLE_UPDATE_ENDED,e('VARIABLE_UPDATE_ENDED')),eventOn(tavern_events.MESSAGE_DELETED,e('MESSAGE_DELETED')),n('[EventDispatcher] MVU监听器部署完毕。')}(),T=!0,n('【观察哨】(探针) 阶段三成功：MVU集成已完全激活。'),n('【安全观察哨】任务成功完成！','groupEnd'),!0}catch(e){return n(`【观察哨】(探针) 阶段三失败：激活序列发生意外崩溃: ${e}`,'error'),T=!1,n('【安全观察哨】任务失败。','groupEnd'),!1}}())throw new Error('MVU集成初始化失败或超时，部分功能将不可用。');n('【指挥官】MVU已完全就绪，可以安全继续。')}else n('【指挥官】(路径选择) 检测到纯文字卡，进入“快速路径”。');n('【指挥官】所有前置条件满足，开始执行播放器核心初始化...');let r=null;t?(n('【指挥官】(查询) 正在为MVU卡查找权威状态...'),r=await U()):n('【指挥官】(跳过) 纯文字卡，无需查找MVU状态。'),await B(e,r),n('[EventDispatcher] 正在注册“上下文专属”事件监听器...'),eventOn(tavern_events.CHARACTER_MESSAGE_RENDERED,e=>{!async function(e){if(n(`[Injector] 捕获到 CHARACTER_MESSAGE_RENDERED 事件，message_id: ${e}`),0!==e)try{const t=getChatMessages(e)?.[0];'assistant'!==t?.role||t.message.includes('<DarkBramblePlayer/>')?n('[Injector] (探针) 操作跳过：消息不满足注入条件 (可能不是AI消息，或已包含标签)。'):(n(`[Injector] (探针) 条件满足，立即为 message_id: ${e} 执行注入...`),await setChatMessages([{message_id:e,message:`${t.message}\n<DarkBramblePlayer/>`}],{refresh:'none'}),n('[Injector] (探针) 注入成功。'))}catch(t){n(`[Injector] 为 message_id: ${e} 注入标签时发生严重错误:`,'error'),console.error(t)}else n('[Injector] (探针) 操作中止：message_id 为 0 (开场白)，无需注入。')}(e)}),eventOn(tavern_events.MESSAGE_SWIPED,e=>{if(n(`[Event] 捕获到滑动事件 (message_id: ${e})。`),k)if(0===e){n('[Event-Swipe] 判断为开场白滑动，执行软重置...');const e=p.isPlaying();n(`[Event-Swipe] (探针) 软重置前的播放状态: ${e}`),async function(e){n('[SoftReset] 检测到根本性上下文变更，启动“软重置”协议...','warn');try{const t=await N();n('[SoftReset] 正在为新的开场白查找权威MVU状态...');const r=await U();await B(t,r,e)}catch(e){n('[SoftReset] 软重置过程中发生严重错误。','error'),console.error(e)}}({autoPlayIfWasPlaying:e})}else n('[Event-Swipe] 判断为历史消息滑动，执行历史变更处理...'),async function(e,t){if(n(`[HistoryChange] 检测到历史变更事件: ${e}。`),!k)return;n('[HistoryChange-Probe] 正在查询最新的权威MVU状态...');const r=await U();if(!r?.mvuData)return n('[HistoryChange] (守门员) 未找到有效的权威状态。这在AI重新生成期间是正常现象。','warn'),void n('[HistoryChange] (守门员) 采取“静默等待”策略，本次校准已跳过。');console.log('[HistoryChange-Probe] 查询完毕，这是找到的权威状态数据，请您审查：'),console.dir(_.cloneDeep(r?.mvuData)),await V(r?.mvuData,t)}('MESSAGE_SWIPED',{transitionEffect:'hard'})}),n('[EventDispatcher] “上下文专属”事件监听器注册完毕。'),w&&(n('【指挥官】(探针) 后台初始化成功，兑现 Promise 契约，唤醒前端。'),w.resolve())}catch(e){if(n(`【指挥官】在初始化主流程中发生严重错误: ${e}`,'error'),w){const t=e instanceof Error?e.message:String(e);w.reject(t)}}finally{w=null,n('【初始化指挥官 V9.8】协议执行完毕。','groupEnd')}}}$(()=>{n('音乐播放器脚本 V8.4 “上下文感知” 启动'),y.initialize(),K(),eventOn(tavern_events.CHAT_CHANGED,()=>{n('[硬重置] CHAT_CHANGED 事件触发，检测到聊天上下文变更。即将执行“优雅停机”协议。','warn'),n('[HardReset] “优雅停机”协议启动...','warn'),C=!1,y.getActivePlayer()?.pause(),n('[HardReset] 音频已暂停。'),n('[HardReset] 即将调用 reloadIframe()。'),reloadIframe()});const e=setInterval(()=>{X(),E&&(clearInterval(e),n('【观察者模型】初始化成功，观察者已销毁。'))},250);setTimeout(()=>{E||(clearInterval(e),n('【观察者模型】初始化超时！','error'),w&&(w.reject('Initialization timed out after 5 seconds.'),w=null))},5e3),$(window).on('pagehide',()=>{n('PAGEHIDE 事件触发！','warn'),y.getActivePlayer()?.pause(),n('音频已暂停。')})});export{c as ZodPersistedState,i as ZodPlaylistConfig,s as ZodQueueItemState,a as ZodSingleCondition,r as ZodTrackConfig,o as ZodTriggerConfig,l as ZodWorldbookConfig};
//# sourceMappingURL=index.js.map