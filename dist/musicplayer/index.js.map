{"version":3,"file":"index.js","mappings":"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","sources":["src://tavern_helper_template/external var \"z\"","src://tavern_helper_template/src/musicplayer/index.ts"],"sourcesContent":["const __WEBPACK_NAMESPACE_OBJECT__ = z;","console.log('音乐播放器脚本 V-DarkBramblePlayer 11.2版本！');\n\n// =================================================================\n// 0. 诊断工具 (Diagnostic Tools)\n// =================================================================\nimport { z, ZodError } from 'zod';\ndeclare global {\n  interface Window {\n    musicPlayerAPI: any;\n  }\n}\nconst SCRIPT_LOAD_TIME = performance.now();\n\nfunction logProbe(message: string, type: 'log' | 'warn' | 'error' | 'group' | 'groupCollapsed' | 'groupEnd' = 'log') {\n  const timestamp = `(T+${(performance.now() - SCRIPT_LOAD_TIME).toFixed(0)}ms)`;\n  const finalMessage = `${timestamp} ${message}`;\n\n  switch (type) {\n    case 'warn':\n      console.warn(finalMessage);\n      break;\n    case 'error':\n      console.error(finalMessage);\n      break;\n    case 'group':\n      console.group(finalMessage);\n      break;\n    case 'groupCollapsed':\n      console.groupCollapsed(finalMessage);\n      break;\n    case 'groupEnd':\n      console.groupEnd();\n      break;\n    default:\n      console.log(finalMessage);\n  }\n}\n\n// =================================================================\n// 1. 类型定义 (Type Definitions)\n// =================================================================\n\ntype PlaylistItem = {\n  url: string;\n  歌名: string;\n  歌手?: string;\n  封面?: string;\n};\n\ntype PlaylistConfig = {\n  id: string;\n  tracks: PlaylistItem[];\n  onFinishRule: 'loop' | 'pop';\n};\n\ntype QueueItem = {\n  // --- 核心标识与排序依据 ---\n  playlistId: string;\n  priority: number;\n\n  // --- 内容与规则 ---\n  playlistContent: PlaylistItem[];\n  onFinishRule: 'loop' | 'pop';\n\n  // --- 状态记忆 ---\n  currentIndex: number;\n  playedIndices: Set<number>;\n  playbackPlan?: number[];\n  planIndex?: number;\n  wasEverPlayed: boolean;\n\n  // --- 溯源信息 ---\n  triggeredBy: 'base' | 'mvu';\n  triggerSource?: z.infer<typeof ZodTriggerConfig>;\n};\n\ntype PlaybackMode = 'list' | 'single' | 'random';\n\ntype FullStatePayload = {\n  currentItem: { title: string; artist?: string; cover?: string } | null;\n  isPlaying: boolean;\n  playbackMode: PlaybackMode;\n  masterVolume: number;\n  playlist: { title: string; artist?: string; cover?: string }[];\n  isTransitioning: boolean;\n};\n\ntype TimeUpdatePayload = {\n  currentTime: number;\n  duration: number;\n};\n\ntype StrategyDecision = {\n  action: 'GoTo' | 'RemoveTopAndAdvance' | 'Restart' | 'DoNothing' | 'LoopReset' | 'Stop';\n  nextIndex?: number;\n};\n\ninterface IPlaybackStrategy {\n  onQueueChanged(currentItem: QueueItem | undefined): void;\n  advance(currentItem: QueueItem, direction: 'next' | 'prev'): StrategyDecision;\n  onTrackEnd(currentItem: QueueItem): StrategyDecision;\n  onPlaybackError(currentItem: QueueItem): StrategyDecision;\n}\n\n// =================================================================\n// 1.1. Zod 边界防御 Schemas (Zod Border Defense Schemas)\n// -----------------------------------------------------------------\n// 探针: 这些 schemas 不仅仅是类型，它们是主动的验证器，是我们系统的第一道防线。\n//       每一个 `required_error` 和 `message` 都是一个内置的探针，当外部数据\n//       不符合我们的“法律”时，它们会自动报告错误。\n// 原则: 单一事实来源 (SSoT) - 关于外部数据应该长什么样的“真相”，只由这里定义。\n// =================================================================\n\n// 世界书音轨配置 Schema\nexport const ZodTrackConfig = z\n  .object({\n    歌名: z.string().optional(),\n    歌手: z.string().optional(),\n    封面: z.string().url({ message: '封面URL格式无效' }).optional(),\n    url: z.string().url({ message: '音轨URL格式无效' }),\n  })\n  .strict();\n\n// 定义一个“单一条件”\nexport const ZodSingleCondition = z\n  .object({\n    variable_path: z.string(),\n    greater_than: z.number().optional(),\n    greater_than_or_equal_to: z.number().optional(),\n    less_than: z.number().optional(),\n    less_than_or_equal_to: z.number().optional(),\n    value: z.union([z.string(), z.number(), z.boolean()]).optional(),\n    value_contains: z.string().optional(),\n    time_in_range: z\n      .string()\n      .regex(/^\\d{2}:\\d{2}-\\d{2}:\\d{2}$/, {\n        message: '时间范围格式必须是 \"HH:MM-HH:MM\"',\n      })\n      .optional(),\n  })\n  .strict();\n\n// 主触发器 Schema 引用“单一条件”的数组\nexport const ZodTriggerConfig = z\n  .object({\n    type: z.literal('mvu_variable'),\n    playlist_id: z.string(),\n    priority: z.number().default(0),\n    conditions: z.array(ZodSingleCondition).nonempty({ message: '触发器必须至少包含一个条件' }),\n  })\n  .strict();\n\n// 世界书歌单配置 Schema\nexport const ZodPlaylistConfig = z.object({\n  id: z.string(),\n  onFinishRule: z.enum(['loop', 'pop'], { message: \"onFinishRule 必须是 'loop' 或 'pop'\" }).default('loop'),\n  tracks: z.array(ZodTrackConfig).nonempty({ message: \"歌单的 'tracks' 列表不能为空\" }),\n});\n\n// 世界书总配置 Schema (这是我们将使用的顶级验证器)\nexport const ZodWorldbookConfig = z\n  .object({\n    default_playlist_id: z.string().optional(),\n    playlists: z.array(ZodPlaylistConfig).optional(),\n    triggers: z.array(ZodTriggerConfig).optional(),\n  })\n  .strict();\n\n// 持久化状态 - 队列项 Schema\nexport const ZodQueueItemState = z.object({\n  playlistId: z.string(),\n  currentIndex: z.number().default(0),\n  playedIndices: z.array(z.number()).default([]),\n  wasEverPlayed: z.boolean().default(false),\n  triggerSource: ZodTriggerConfig.optional(),\n});\n\n// 持久化状态 - 总 Schema\nexport const ZodPersistedState = z.object({\n  active_queue: z.array(ZodQueueItemState),\n  mode: z.enum(['list', 'single', 'random']).default('list'),\n  volume: z.number().min(0).max(1).default(0.5),\n  previousMvuState: z.record(z.string(), z.any()).optional(),\n});\n\nconst STATE_KEY_MVU_HISTORY = '灰烬双星_MVU状态记忆';\n\n/**\n * [工具函数] 将多种格式的时间字符串解析为从午夜开始的分钟数。\n * 它的职责单一，且对输入格式有很强的容错能力。\n * @param timeStr - 例如 \"14:30\", \"8时5分\", \"22 : 00\"\n * @returns {number | null} 转换后的分钟数，或在无法解析时返回 null。\n */\nfunction _parseTimeToMinutes(timeStr: string): number | null {\n  // 探针: 记录传入的原始值，便于调试\n  if (!timeStr || typeof timeStr !== 'string') return null;\n\n  // 步骤1: 归一化输入，处理常见变体 (已修正 let -> const 和 replace 语法)\n  const cleanStr: string = timeStr.trim().replace('：', ':');\n\n  let match;\n\n  // 步骤2: 尝试匹配 \"HH:MM\" 格式 (最常见)\n  match = cleanStr.match(/^(\\d{1,2})\\s*:\\s*(\\d{1,2})$/);\n  if (match) {\n    const hours = parseInt(match[1], 10);\n    const minutes = parseInt(match[2], 10);\n    // 严格校验数值范围\n    if (hours >= 0 && hours < 24 && minutes >= 0 && minutes < 60) {\n      return hours * 60 + minutes;\n    }\n  }\n\n  // 步骤3: 尝试匹配 \"H时M分\" 格式\n  match = cleanStr.match(/^(\\d{1,2})\\s*时\\s*(\\d{1,2})\\s*分?$/);\n  if (match) {\n    const hours = parseInt(match[1], 10);\n    const minutes = parseInt(match[2], 10);\n    if (hours >= 0 && hours < 24 && minutes >= 0 && minutes < 60) {\n      return hours * 60 + minutes;\n    }\n  }\n\n  // 探针: 如果所有格式都匹配失败，记录下来\n  logProbe(`[TimeParser] 无法解析时间字符串: \"${timeStr}\"`, 'warn');\n\n  // [新增] 修复“缺少 return”的逻辑漏洞\n  return null;\n}\n\n// =================================================================\n// 2. MVU 管理器 (The MvuManager - \"The Analyst\")\n// =================================================================\nconst MvuManager = (() => {\n  logProbe('[MvuManager] 模块正在初始化...');\n\n  let _previousMvuState: Record<string, any> = {};\n\n  /**\n   * [核心算法 V2.1] 检查一个给定的 stat_data 是否满足一个触发器的所有条件。\n   * 新版已加固，支持多种匹配模式和 AND 条件组合，且代码风格已优化。\n   */\n  function _checkTriggerCondition(\n    trigger: z.infer<typeof ZodTriggerConfig>,\n    statData: Record<string, any> | null,\n  ): boolean {\n    if (!statData) return false;\n\n    // 遍历所有 AND 条件。只要有一个不满足，整个触发器就失败。\n    for (const condition of trigger.conditions) {\n      const currentValue = _.get(statData, condition.variable_path);\n\n      let conditionMet = false; // 当前条件是否满足\n      let isHandled = false; // 当前条件是否被任何一个匹配模式处理过\n\n      // 使用 if / else if 链条，确保每个条件项只采用一种匹配模式\n      if (condition.value_contains !== undefined) {\n        isHandled = true;\n        // [安全加固] 必须检查 currentValue 是字符串，否则 .includes() 会导致崩溃\n        if (typeof currentValue === 'string' && currentValue.includes(condition.value_contains)) {\n          conditionMet = true;\n        }\n      } else if (condition.time_in_range !== undefined) {\n        isHandled = true;\n        // [安全加固] 同样检查类型\n        if (typeof currentValue === 'string') {\n          const currentTimeInMinutes = _parseTimeToMinutes(currentValue);\n\n          if (currentTimeInMinutes !== null) {\n            const [startStr, endStr] = condition.time_in_range.split('-');\n            const startMinutes = _parseTimeToMinutes(startStr);\n            const endMinutes = _parseTimeToMinutes(endStr);\n\n            if (startMinutes !== null && endMinutes !== null) {\n              // [代码风格修正] 移除不必要的嵌套 if，使代码更简洁\n              if (startMinutes <= endMinutes) {\n                // 普通范围\n                conditionMet = currentTimeInMinutes >= startMinutes && currentTimeInMinutes <= endMinutes;\n              } else {\n                // 跨天范围\n                conditionMet = currentTimeInMinutes >= startMinutes || currentTimeInMinutes <= endMinutes;\n              }\n            }\n          }\n        }\n      } else if (condition.value !== undefined) {\n        isHandled = true;\n        if (currentValue === condition.value) {\n          conditionMet = true;\n        }\n      } else if (condition.greater_than !== undefined) {\n        isHandled = true;\n        if (typeof currentValue === 'number' && currentValue > condition.greater_than) {\n          conditionMet = true;\n        }\n      } else if (condition.greater_than_or_equal_to !== undefined) {\n        isHandled = true;\n        if (typeof currentValue === 'number' && currentValue >= condition.greater_than_or_equal_to) {\n          conditionMet = true;\n        }\n      } else if (condition.less_than !== undefined) {\n        isHandled = true;\n        if (typeof currentValue === 'number' && currentValue < condition.less_than) {\n          conditionMet = true;\n        }\n      } else if (condition.less_than_or_equal_to !== undefined) {\n        isHandled = true;\n        if (typeof currentValue === 'number' && currentValue <= condition.less_than_or_equal_to) {\n          conditionMet = true;\n        }\n      }\n\n      // [最终裁决] 如果这是一个空条件 (isHandled=false)，或条件不满足，则立即失败\n      if (!isHandled || !conditionMet) {\n        return false;\n      }\n    }\n\n    // 如果循环正常结束，说明所有 AND 条件都满足\n    return true;\n  }\n\n  // --- 公共接口 ---\n  const publicAPI = {\n    checkTriggerCondition: _checkTriggerCondition,\n\n    /**\n     * [生命周期] 从酒馆变量中读取并恢复上一次的 MVU 状态。\n     */\n    initialize() {\n      logProbe('[MvuManager] (Lifecycle) 执行 initialize...');\n      try {\n        const savedState = getVariables({ type: 'chat' })[STATE_KEY_MVU_HISTORY];\n        if (savedState && typeof savedState === 'object') {\n          _previousMvuState = savedState;\n          logProbe('[MvuManager] 成功从存档中恢复了 MVU 历史状态。');\n        } else {\n          _previousMvuState = {};\n          logProbe('[MvuManager] 未发现有效的 MVU 历史存档，已初始化为空状态。', 'warn');\n        }\n      } catch (error) {\n        logProbe(`[MvuManager] 初始化时读取存档失败: ${error}`, 'error');\n        _previousMvuState = {};\n      }\n    },\n\n    resetState() {\n      logProbe('[MvuManager] (Lifecycle) 正在重置模块内部状态...');\n      _previousMvuState = {};\n      logProbe('[MvuManager] 模块状态已重置。');\n    },\n\n    /**\n     * [命令] 将当前的 MVU 状态持久化到酒馆变量中。\n     * @param currentStateData - 最新的 stat_data 对象。\n     */\n    async persistCurrentState(currentStateData: Record<string, any>) {\n      if (!isScriptActive) {\n        logProbe('[MvuManager] 持久化操作被阻止，因为脚本正在停机。', 'warn');\n        return;\n      }\n      logProbe('[MvuManager] (Command) 执行 persistCurrentState...');\n      _previousMvuState = _.cloneDeep(currentStateData);\n      try {\n        await updateVariablesWith(\n          vars => {\n            vars[STATE_KEY_MVU_HISTORY] = _previousMvuState;\n            return vars;\n          },\n          { type: 'chat' },\n        );\n        logProbe('[MvuManager] 已成功将当前 MVU 状态持久化。');\n      } catch (error) {\n        logProbe(`[MvuManager] 持久化 MVU 状态时发生严重错误: ${error}`, 'error');\n      }\n    },\n\n    /**\n     * [查询] 获取内存中存储的上一次的 MVU 状态。\n     */\n    getPreviousState: () => _.cloneDeep(_previousMvuState),\n\n    /**\n     * [核心查询] 计算新旧状态之间的“边沿变化”。\n     * @param previousStateData - 上一次的 stat_data。\n     * @param currentStateData - 最新的 stat_data。\n     * @param allTriggers - 从世界书解析出的所有有效触发器。\n     * @returns 报告对象，包含新激活和新失效的触发器列表。\n     */\n    calculateChangeReport(\n      previousStateData: Record<string, any>,\n      currentStateData: Record<string, any>,\n      allTriggers: z.infer<typeof ZodTriggerConfig>[],\n    ): {\n      newlyActiveTriggers: z.infer<typeof ZodTriggerConfig>[];\n      newlyInactiveTriggers: z.infer<typeof ZodTriggerConfig>[];\n    } {\n      const report: {\n        newlyActiveTriggers: z.infer<typeof ZodTriggerConfig>[];\n        newlyInactiveTriggers: z.infer<typeof ZodTriggerConfig>[];\n      } = { newlyActiveTriggers: [], newlyInactiveTriggers: [] };\n\n      logProbe('[MvuManager] (Query) 正在计算状态变化报告 (\"边沿检测\")...', 'group');\n\n      logProbe('[Probe] 正在审查用于对比的新旧状态数据:');\n      console.log('上一份历史记忆 (previousStateData):');\n      console.dir(_.cloneDeep(previousStateData));\n      console.log('当前权威状态 (currentStateData):');\n      console.dir(_.cloneDeep(currentStateData));\n      // =======================================================\n\n      for (const trigger of allTriggers) {\n        const wasMet = _checkTriggerCondition(trigger, previousStateData);\n        const isMet = _checkTriggerCondition(trigger, currentStateData);\n\n        if (!wasMet && isMet) {\n          logProbe(`(探針) 新激活的触发器 -> playlist: \"${trigger.playlist_id}\"`);\n          report.newlyActiveTriggers.push(trigger);\n        } else if (wasMet && !isMet) {\n          logProbe(`(探針) 新失效的触发器 -> playlist: \"${trigger.playlist_id}\"`);\n          report.newlyInactiveTriggers.push(trigger);\n        }\n      }\n      logProbe(\n        `报告生成完毕: ${report.newlyActiveTriggers.length} 个新激活, ${report.newlyInactiveTriggers.length} 个新失效。`,\n      );\n      logProbe('', 'groupEnd');\n      return report;\n    },\n  };\n\n  logProbe('[MvuManager] 模块初始化完成。');\n  return publicAPI;\n})();\n\n// =================================================================\n// 2. 状态管理器 (The State Manager) - [V2.0 重构版]\n// =================================================================\nconst StateManager = (() => {\n  logProbe('[StateManager] 模块正在初始化 (优先级队列内核)...');\n\n  // -------------------\n  // 2.1. 私有状态 (Private State)\n  // -------------------\n  // [重构] 核心数据结构变更为优先级队列\n  let _activePlaylistQueue: QueueItem[] = [];\n\n  let _playbackMode: PlaybackMode = 'list';\n  let _masterVolume: number = 0.5;\n  let _isPlaying: boolean = false;\n  let _isPerformingEffect: boolean = false;\n\n  // -------------------\n  // 2.2. 私有核心算法 (Private Core Algorithms)\n  // -------------------\n  function _applyDepartureIsHistoryPrinciple(item: QueueItem, departingIndex: number) {\n    if (typeof departingIndex !== 'number' || departingIndex < 0) return;\n    item.playedIndices.add(departingIndex);\n  }\n\n  // -------------------\n  // 2.3. 公共接口 (Public API)\n  // -------------------\n  const publicAPI = {\n    // --- 基础状态查询 ---\n    getPlaybackMode: () => _playbackMode,\n    getVolume: () => _masterVolume,\n    isPlaying: () => _isPlaying,\n    isPerformingEffect: () => _isPerformingEffect,\n\n    // --- [重构] 队列核心查询 ---\n    /**\n     * 获取当前优先级最高的歌单项（队首）。\n     * 这是系统唯一的事实来源：当前应该播放什么。\n     */\n    getTopQueueItem: (): QueueItem | undefined => _.cloneDeep(_activePlaylistQueue[0]),\n\n    /**\n     * 获取整个队列的副本（用于调试或决策分析）。\n     */\n    getQueue: (): QueueItem[] => _.cloneDeep(_activePlaylistQueue),\n\n    // --- 状态快照 ---\n    getStateSnapshotForRuntime: () => {\n      return _.cloneDeep({\n        active_queue: _activePlaylistQueue,\n        mode: _playbackMode,\n        volume: _masterVolume,\n        isPlaying: _isPlaying,\n        isPerformingEffect: _isPerformingEffect,\n      });\n    },\n\n    getStateSnapshotForPersistence() {\n      const runtimeQueue = _.cloneDeep(_activePlaylistQueue);\n\n      const persistentQueue = runtimeQueue.map(item => {\n        const persistedItem = _.omit(item, ['playbackPlan', 'planIndex', 'playlistContent']);\n\n        return {\n          ...persistedItem,\n          // 将 Set 转换为 Array 以便 JSON 序列化\n          playedIndices: Array.from(item.playedIndices),\n        };\n      });\n\n      return {\n        active_queue: persistentQueue,\n        mode: _playbackMode,\n        volume: _masterVolume,\n        // previousMvuState 由 MvuManager 单独管理，此处仅返回核心状态\n      };\n    },\n\n    // --- 生命周期管理 ---\n    resetState() {\n      logProbe('[StateManager] 正在硬性重置所有状态...', 'warn');\n      _activePlaylistQueue = [];\n      _playbackMode = 'list';\n      _masterVolume = 0.5;\n      _isPlaying = false;\n      _isPerformingEffect = false;\n    },\n\n    loadState(stateToLoad: any) {\n      logProbe('[StateManager] 正在加载状态...', 'group');\n      _playbackMode = stateToLoad.mode;\n      _masterVolume = stateToLoad.volume;\n      _activePlaylistQueue = stateToLoad.active_queue || [];\n      logProbe(\n        `状态加载完成. 队列深度: ${_activePlaylistQueue.length}, 模式: ${_playbackMode}, 音量: ${_masterVolume}`,\n      );\n      logProbe('', 'groupEnd');\n    },\n\n    // --- 基础状态设置 ---\n    setPlaybackMode: (mode: PlaybackMode) => {\n      _playbackMode = mode;\n    },\n    setVolume: (volume: number) => {\n      _masterVolume = volume;\n    },\n    setPlaying: (playing: boolean) => {\n      _isPlaying = playing;\n    },\n    setPerformingEffect: (isPerforming: boolean) => {\n      _isPerformingEffect = isPerforming;\n    },\n\n    // --- [重构] 队列核心操作 ---\n    /**\n     * [核心] 更新整个队列。\n     * 此方法会自动按优先级降序排列队列，确保 _activePlaylistQueue[0] 永远是优先级最高的。\n     */\n    updateQueue(newQueue: QueueItem[]) {\n      logProbe(`[StateManager] (Command) updateQueue: 正在更新并重排序队列 (共 ${newQueue.length} 项)...`);\n\n      _activePlaylistQueue = _.cloneDeep(newQueue).sort((a, b) => b.priority - a.priority);\n\n      if (_activePlaylistQueue.length > 0) {\n        logProbe(\n          `(探针) 新队首: \"${_activePlaylistQueue[0].playlistId}\" (优先级: ${_activePlaylistQueue[0].priority})`,\n        );\n      } else {\n        logProbe(`(探针) 队列现已为空。`);\n      }\n    },\n\n    // --- 当前项操作 (作用于队首) ---\n    setCurrentIndex(index: number) {\n      const currentItem = _activePlaylistQueue[0];\n      if (currentItem) {\n        _applyDepartureIsHistoryPrinciple(currentItem, currentItem.currentIndex);\n        currentItem.currentIndex = index;\n      }\n    },\n\n    commitNavigationStep(newTrackIndex: number) {\n      const currentItem = _activePlaylistQueue[0];\n      if (!currentItem) return;\n\n      _applyDepartureIsHistoryPrinciple(currentItem, currentItem.currentIndex);\n\n      if (_playbackMode === 'random' && currentItem.playbackPlan) {\n        const newPlanIndex = currentItem.playbackPlan.indexOf(newTrackIndex);\n        if (newPlanIndex !== -1) {\n          currentItem.planIndex = newPlanIndex;\n        }\n      }\n      currentItem.currentIndex = newTrackIndex;\n    },\n\n    clearHistoryForCurrentItem() {\n      const currentItem = _activePlaylistQueue[0];\n      if (currentItem) currentItem.playedIndices.clear();\n    },\n\n    resetCurrentItemForLoop() {\n      const currentItem = _activePlaylistQueue[0];\n      if (currentItem) {\n        currentItem.playedIndices.clear();\n        currentItem.currentIndex = 0;\n      }\n    },\n\n    commitGenesisState(newCurrentIndex: number, newPlaybackPlan: number[], newPlanIndex: number) {\n      const currentItem = _activePlaylistQueue[0];\n      if (currentItem) {\n        currentItem.currentIndex = newCurrentIndex;\n        currentItem.playbackPlan = newPlaybackPlan;\n        currentItem.planIndex = newPlanIndex;\n      }\n    },\n\n    userInitiatedJump(trackIndex: number) {\n      const currentItem = _activePlaylistQueue[0];\n      if (!currentItem || trackIndex === currentItem.currentIndex) return;\n\n      _applyDepartureIsHistoryPrinciple(currentItem, currentItem.currentIndex);\n      currentItem.currentIndex = trackIndex;\n\n      if (this.getPlaybackMode() === 'random' && currentItem.playbackPlan) {\n        const newPlanIndex = currentItem.playbackPlan.indexOf(trackIndex);\n        if (newPlanIndex !== -1) currentItem.planIndex = newPlanIndex;\n      }\n    },\n\n    clearRandomModePlan() {\n      const currentItem = _activePlaylistQueue[0];\n      if (currentItem) {\n        currentItem.playbackPlan = undefined;\n        currentItem.planIndex = undefined;\n      }\n    },\n\n    applyNewPlaybackPlan(plan: number[], planIndex: number) {\n      const currentItem = _activePlaylistQueue[0];\n      if (currentItem) {\n        currentItem.playbackPlan = plan;\n        currentItem.planIndex = planIndex;\n      }\n    },\n  };\n\n  logProbe('[StateManager] 模块初始化完成 (V2.0 内核)。');\n  return publicAPI;\n})();\n\n// =================================================================\n// 2.1. 播放引擎 (The Playback Engine)\n// =================================================================\nconst PlaybackEngine = (() => {\n  logProbe('[PlaybackEngine] 模块正在初始化...');\n  let _playerA: HTMLAudioElement | null = null;\n  let _playerB: HTMLAudioElement | null = null;\n  let _activePlayer: HTMLAudioElement | null = null;\n  let _standbyPlayer: HTMLAudioElement | null = null;\n  let _fadeInterval: number | null = null;\n  const FADE_DURATION = 400;\n\n  // --- 私有函数 ---\n  function _swapPlayers() {\n    [_activePlayer, _standbyPlayer] = [_standbyPlayer, _activePlayer];\n  }\n\n  function _fadeVolumeAsync(player: HTMLAudioElement | null, targetVolume: number, duration: number): Promise<void> {\n    return new Promise(resolve => {\n      if (_fadeInterval) {\n        clearInterval(_fadeInterval);\n        _fadeInterval = null;\n      }\n\n      if (!player) return resolve();\n\n      const startVolume = player.volume;\n      const stepTime = 50;\n      const steps = duration / stepTime;\n      if (steps <= 0) {\n        player.volume = targetVolume;\n        return resolve();\n      }\n      const volumeStep = (targetVolume - startVolume) / steps;\n      let currentStep = 0;\n\n      _fadeInterval = window.setInterval(() => {\n        currentStep++;\n        if (currentStep >= steps) {\n          if (_fadeInterval) clearInterval(_fadeInterval);\n          _fadeInterval = null;\n          player.volume = targetVolume;\n          resolve();\n        } else {\n          player.volume += volumeStep;\n        }\n      }, stepTime);\n    });\n  }\n\n  // --- 公共接口 ---\n  const publicAPI = {\n    initialize() {\n      if (_playerA && _playerB) return;\n      logProbe('[Engine] 正在创建和配置 HTML5 Audio 元素...');\n      const createPlayer = (): HTMLAudioElement => {\n        const audio = new Audio();\n        audio.preload = 'auto';\n        audio.crossOrigin = 'anonymous';\n        audio.addEventListener('ended', () => {\n          if (audio === _activePlayer) void _handleTrackEnded();\n        });\n        audio.addEventListener('error', () => {\n          /* 错误由 Promise reject 处理 */\n        });\n        audio.addEventListener('timeupdate', broadcastTimeUpdate);\n        return audio;\n      };\n      _playerA = createPlayer();\n      _playerB = createPlayer();\n      _activePlayer = _playerA;\n      _standbyPlayer = _playerB;\n      logProbe('[Engine] Audio 元素已就绪。');\n    },\n\n    getActivePlayer: () => _activePlayer,\n    getStandbyPlayer: () => _standbyPlayer,\n\n    async transitionToTrack(targetTrackUrl: string, targetVolume: number): Promise<void> {\n      logProbe(`[Engine] 收到过渡请求: URL=${targetTrackUrl.slice(0, 50)}...`, 'group');\n\n      if (!_standbyPlayer || !_activePlayer) {\n        logProbe('[Engine] 过渡中止：播放器实例尚未初始化。', 'error');\n        logProbe('', 'groupEnd');\n        throw new Error('播放器实例尚未初始化');\n      }\n\n      const standbyPlayer = _standbyPlayer;\n      const activePlayer = _activePlayer;\n\n      standbyPlayer.src = targetTrackUrl;\n      standbyPlayer.load();\n\n      try {\n        await new Promise<void>((resolve, reject) => {\n          const onCanPlay = () => {\n            standbyPlayer.removeEventListener('canplaythrough', onCanPlay);\n            standbyPlayer.removeEventListener('error', onError);\n            logProbe('[Engine] 备用播放器加载成功 (canplaythrough)。', 'log');\n            resolve();\n          };\n\n          const onError = (e: Event) => {\n            standbyPlayer.removeEventListener('canplaythrough', onCanPlay);\n            standbyPlayer.removeEventListener('error', onError);\n            logProbe(`[Engine] 备用播放器加载失败!`, 'error');\n            const target = e.target as HTMLAudioElement;\n            const error = target.error;\n            reject(new Error(`音频加载失败: ${error?.message || '未知错误'}`));\n          };\n          standbyPlayer.addEventListener('canplaythrough', onCanPlay);\n          standbyPlayer.addEventListener('error', onError);\n        });\n      } catch (error) {\n        logProbe('[Engine] 过渡因加载失败而中止。', 'groupEnd');\n        throw error;\n      }\n\n      await _fadeVolumeAsync(activePlayer, 0, 500);\n      activePlayer.pause();\n\n      _swapPlayers();\n\n      const newActivePlayer = this.getActivePlayer();\n      if (!newActivePlayer) throw new Error('播放器实例在交换后丢失');\n\n      const playPromise = newActivePlayer.play();\n      if (playPromise) {\n        await playPromise;\n      }\n      await _fadeVolumeAsync(newActivePlayer, targetVolume, 500);\n\n      logProbe('[Engine] 过渡成功完成。', 'groupEnd');\n    },\n\n    async fadeOutAndPause(): Promise<void> {\n      logProbe('[Engine] 命令: FadeOutAndPause');\n      await _fadeVolumeAsync(_activePlayer, 0, FADE_DURATION);\n      _activePlayer?.pause();\n    },\n\n    async executeHardCut(targetTrackUrl: string, targetVolume: number): Promise<void> {\n      logProbe(`[Engine:HardCut] 收到“瞬击”请求: URL=${targetTrackUrl.slice(0, 50)}...`, 'group');\n      const activePlayer = this.getActivePlayer();\n      if (!activePlayer) {\n        logProbe('[Engine:HardCut] 致命错误：无可用播放器实例。', 'error');\n        logProbe('', 'groupEnd');\n        throw new Error('No active player available for hard cut.');\n      }\n\n      logProbe(`(探针) 切换前 src: ${activePlayer.src.slice(-50)}`);\n\n      activePlayer.pause();\n      activePlayer.src = targetTrackUrl;\n      activePlayer.volume = targetVolume;\n\n      logProbe(`(探针) 切换后 src: ${activePlayer.src.slice(-50)}`);\n\n      try {\n        const playPromise = activePlayer.play();\n        if (playPromise) {\n          await playPromise;\n        }\n\n        StateManager.setPlaying(true);\n        logProbe('[Engine:HardCut] “瞬击”播放成功。');\n      } catch (error) {\n        logProbe(`[Engine:HardCut] “瞬击”播放失败! 这通常是因为用户未与页面交互。`, 'error');\n\n        StateManager.setPlaying(false);\n\n        throw error;\n      } finally {\n        logProbe('', 'groupEnd');\n      }\n    },\n\n    async resumeAndFadeIn(targetVolume: number): Promise<void> {\n      logProbe('[Engine] 命令: ResumeAndFadeIn');\n      const playPromise = _activePlayer?.play();\n      if (playPromise) await playPromise;\n      await _fadeVolumeAsync(_activePlayer, targetVolume, FADE_DURATION);\n    },\n  };\n\n  logProbe('[PlaybackEngine] 模块初始化完成。');\n  return publicAPI;\n})();\n\n// =================================================================\n// 2.2. 播放策略实现 (Playback Strategies)\n// =================================================================\n\nclass ListStrategy implements IPlaybackStrategy {\n  public onQueueChanged(_currentItem: QueueItem | undefined): void {}\n\n  public advance(currentItem: QueueItem, direction: 'next' | 'prev'): StrategyDecision {\n    logProbe(\n      `[Strategy:List] 收到 advance 请求. 方向: ${direction}, 当前: { playlistId: \"${currentItem.playlistId}\", index: ${currentItem.currentIndex}, rule: \"${currentItem.onFinishRule}\" }`,\n    );\n\n    if (direction === 'next') {\n      logProbe('[Strategy:List] 决策: advance(next) -> 委托给 onTrackEnd');\n      return this.onTrackEnd(currentItem);\n    }\n\n    const { currentIndex, onFinishRule, playlistContent } = currentItem;\n    const totalTracks = playlistContent.length;\n\n    if (currentIndex > 0) {\n      const nextIndex = currentIndex - 1;\n      logProbe(`[Strategy:List] 决策: advance(prev) -> GoTo (index: ${nextIndex})`);\n      return { action: 'GoTo', nextIndex };\n    } else if (onFinishRule === 'loop') {\n      const lastIndex = totalTracks > 0 ? totalTracks - 1 : 0;\n      logProbe(`[Strategy:List] 决策: advance(prev) at start -> Loop to end (index: ${lastIndex})`);\n      return { action: 'GoTo', nextIndex: lastIndex };\n    } else {\n      logProbe('[Strategy:List] 决策: advance(prev) at start -> Restart');\n      return { action: 'Restart' };\n    }\n  }\n\n  public onTrackEnd(currentItem: QueueItem): StrategyDecision {\n    logProbe(\n      `[Strategy:List] 收到 onTrackEnd 请求. 当前: { playlistId: \"${currentItem.playlistId}\", index: ${currentItem.currentIndex}, rule: \"${currentItem.onFinishRule}\" }`,\n    );\n\n    const { currentIndex, onFinishRule, playlistContent, playedIndices } = currentItem;\n    const totalTracks = playlistContent.length;\n    const nextIndex = currentIndex + 1;\n\n    if (nextIndex < totalTracks) {\n      logProbe(`[Strategy:List] 决策: onTrackEnd -> GoTo (index: ${nextIndex})`);\n      return { action: 'GoTo', nextIndex };\n    } else if (onFinishRule === 'pop') {\n      logProbe('[Strategy:List] 决策: onTrackEnd at end -> PopStack');\n      return { action: 'RemoveTopAndAdvance' };\n    } else {\n      const totalValidTracks = playlistContent.length;\n      const historySizeAfterThisTrack = playedIndices.size + 1;\n\n      if (historySizeAfterThisTrack >= totalValidTracks) {\n        logProbe(`[Strategy:List] 决策: onTrackEnd at end -> LoopReset (一个完整的循环已结束)`, 'warn');\n        return { action: 'LoopReset' };\n      } else {\n        logProbe(`[Strategy:List] 决策: onTrackEnd at end -> GoTo (普通循环，继续播放未听过的歌曲)`);\n        return { action: 'GoTo', nextIndex: 0 };\n      }\n    }\n  }\n\n  public onPlaybackError(currentItem: QueueItem): StrategyDecision {\n    logProbe(`[Strategy:List] 收到 onPlaybackError 请求。决策: 委托给 advance('next')`);\n    return this.advance(currentItem, 'next');\n  }\n}\n\n// 用这段代码替换\nclass SingleStrategy implements IPlaybackStrategy {\n  public onQueueChanged(_currentItem: QueueItem | undefined): void {}\n\n  public advance(_currentItem: QueueItem, direction: 'next' | 'prev'): StrategyDecision {\n    logProbe(`[Strategy:Single] 收到 advance 请求. 方向: ${direction}. 决策: Restart`);\n    return { action: 'Restart' };\n  }\n\n  public onTrackEnd(_currentItem: QueueItem): StrategyDecision {\n    logProbe(`[Strategy:Single] 收到 onTrackEnd 请求. 决策: Restart`);\n    return { action: 'Restart' };\n  }\n\n  public onPlaybackError(_currentItem: QueueItem): StrategyDecision {\n    logProbe(`[Strategy:Single] 收到 onPlaybackError 请求。决策: Stop (单曲循环下无法自动前进)`);\n    return { action: 'Stop' };\n  }\n}\n\nclass RandomStrategy implements IPlaybackStrategy {\n  private _generateIntelligentShuffle(\n    allTrackIndices: number[],\n    playedIndices: Set<number>,\n    currentIndex: number,\n  ): number[] {\n    logProbe(`[Strategy:Random] (Algo) _generateIntelligentShuffle 执行...`, 'groupCollapsed');\n    logProbe(\n      `输入: allIndices.length=${allTrackIndices.length}, playedIndices.size=${playedIndices.size}, currentIndex=${currentIndex}`,\n    );\n\n    const sourceForShuffle = allTrackIndices.filter(i => !playedIndices.has(i) && i !== currentIndex);\n    logProbe(`计算待选池 (sourceForShuffle) 大小: ${sourceForShuffle.length}`);\n\n    for (let i = sourceForShuffle.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [sourceForShuffle[i], sourceForShuffle[j]] = [sourceForShuffle[j], sourceForShuffle[i]];\n    }\n\n    logProbe(`洗牌完成. 输出 shuffledIndices (纯粹的未来队列): [${sourceForShuffle.join(', ')}]`);\n    logProbe('', 'groupEnd');\n    return sourceForShuffle;\n  }\n\n  private _generatePlaybackPlan(\n    playedIndices: Set<number>,\n    currentIndex: number,\n    shuffledIndices: number[],\n  ): { playbackPlan: number[]; planIndex: number } {\n    logProbe(`[Strategy:Random] (Algo) _generatePlaybackPlan 执行...`, 'groupCollapsed');\n    logProbe(\n      `输入: playedIndices.size=${playedIndices.size}, currentIndex=${currentIndex}, shuffledIndices.length=${shuffledIndices.length}`,\n    );\n\n    const knownSequence = Array.from(new Set([...playedIndices, currentIndex]));\n    const planIndex = knownSequence.indexOf(currentIndex);\n    const playbackPlan = [...knownSequence, ...shuffledIndices];\n\n    logProbe(`(守护者探针) \"已知序列\" (unique history + current): [${knownSequence.join(', ')}]`);\n    logProbe(`生成导航地图 (playbackPlan): [${playbackPlan.join(', ')}]`);\n    logProbe(`定位导航指针 (planIndex): ${planIndex}`);\n    logProbe('', 'groupEnd');\n\n    return { playbackPlan, planIndex };\n  }\n\n  private _handlePlanEnd(currentItem: QueueItem): StrategyDecision {\n    logProbe(`[Strategy:Random] (Helper) _handlePlanEnd: 已到达计划终点，开始进行边界决策...`, 'groupCollapsed');\n    logProbe(`(探针) 待决策歌单: \"${currentItem.playlistId}\", 结束规则: \"${currentItem.onFinishRule}\"`);\n\n    if (currentItem.onFinishRule === 'pop') {\n      logProbe(`(边界决策) onFinishRule 为 'pop'，决策 -> PopStack`);\n      logProbe('', 'groupEnd');\n      return { action: 'RemoveTopAndAdvance' };\n    } else {\n      logProbe(`(边界决策) onFinishRule 为 'loop'，决策 -> LoopReset`);\n      logProbe('', 'groupEnd');\n      return { action: 'LoopReset' };\n    }\n  }\n\n  public onQueueChanged(currentItem: QueueItem | undefined): void {\n    if (!currentItem) {\n      logProbe('[Strategy:Random] onQueueChanged 中止：无有效的当前项。');\n      return;\n    }\n\n    logProbe(\n      `[Strategy:Random] onQueueChanged 已触发 (连续性恢复)，将为歌单 \"${currentItem.playlistId}\" 生成播放计划...`,\n    );\n\n    const allIndices = currentItem.playlistContent.map((_, i) => i);\n    const shuffled = this._generateIntelligentShuffle(allIndices, currentItem.playedIndices, currentItem.currentIndex);\n    const { playbackPlan, planIndex } = this._generatePlaybackPlan(\n      currentItem.playedIndices,\n      currentItem.currentIndex,\n      shuffled,\n    );\n\n    StateManager.applyNewPlaybackPlan(playbackPlan, planIndex);\n  }\n\n  public prepareGenesis(currentItem: QueueItem | undefined): {\n    newCurrentIndex: number;\n    newPlaybackPlan: number[];\n    newPlanIndex: number;\n  } | null {\n    if (!currentItem || !currentItem.playlistContent) {\n      logProbe('[Strategy:Random] prepareGenesis 中止：传入的队列项无效。', 'error');\n      return null;\n    }\n\n    logProbe('[Strategy:Random] (Query) prepareGenesis: 收到“创世乐谱”谱写请求...', 'group');\n\n    const allIndices = currentItem.playlistContent.map((_, i) => i);\n    for (let i = allIndices.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [allIndices[i], allIndices[j]] = [allIndices[j], allIndices[i]];\n    }\n\n    const newPlaybackPlan = allIndices;\n    const newPlanIndex = 0;\n    const newCurrentIndex = newPlaybackPlan[newPlanIndex];\n\n    logProbe(`(乐谱) 谱写完成。New CurrentIndex: ${newCurrentIndex}, New PlanIndex: ${newPlanIndex}`);\n    logProbe('', 'groupEnd');\n\n    return { newCurrentIndex, newPlaybackPlan, newPlanIndex };\n  }\n\n  public advance(currentItem: QueueItem, direction: 'next' | 'prev'): StrategyDecision {\n    logProbe(`[Strategy:Random] 收到 advance 请求. 方向: ${direction}`, 'groupCollapsed');\n\n    const { playbackPlan, planIndex } = currentItem;\n\n    if (!playbackPlan || planIndex === undefined) {\n      logProbe('[Strategy:Random] 决策中止：导航计划 (playbackPlan) 尚未初始化。', 'error');\n      logProbe('', 'groupEnd');\n      return { action: 'DoNothing' };\n    }\n\n    logProbe(`(探针) 当前导航指针 (planIndex): ${planIndex}`);\n    logProbe(`(探针) 导航地图 (playbackPlan): [${playbackPlan.join(', ')}]`);\n\n    if (direction === 'next') {\n      const nextPlanIndex = planIndex + 1;\n\n      if (nextPlanIndex < playbackPlan.length) {\n        const targetTrackIndex = playbackPlan[nextPlanIndex];\n        logProbe(\n          `[Strategy:Random] 决策: advance(next) -> GoTo (新 planIndex: ${nextPlanIndex}, 目标 trackIndex: ${targetTrackIndex})`,\n        );\n        logProbe('', 'groupEnd');\n        return { action: 'GoTo', nextIndex: targetTrackIndex };\n      } else {\n        logProbe('[Strategy:Random] advance(next) 已到达计划终点，委托给 _handlePlanEnd...');\n        logProbe('', 'groupEnd');\n        return this._handlePlanEnd(currentItem);\n      }\n    } else {\n      // direction === 'prev'\n      const prevPlanIndex = planIndex - 1;\n\n      if (prevPlanIndex >= 0) {\n        const targetTrackIndex = playbackPlan[prevPlanIndex];\n        logProbe(\n          `[Strategy:Random] 决策: advance(prev) -> GoTo (新 planIndex: ${prevPlanIndex}, 目标 trackIndex: ${targetTrackIndex})`,\n        );\n        logProbe('', 'groupEnd');\n        return { action: 'GoTo', nextIndex: targetTrackIndex };\n      } else {\n        logProbe(`[Strategy:Random] 决策: advance(prev) 已在计划起点。返回 DoNothing。`);\n        logProbe('', 'groupEnd');\n        return { action: 'DoNothing' };\n      }\n    }\n  }\n\n  public onTrackEnd(currentItem: QueueItem): StrategyDecision {\n    logProbe(`[Strategy:Random] 收到 onTrackEnd 请求.`, 'groupCollapsed');\n\n    const { playbackPlan, planIndex } = currentItem;\n\n    if (!playbackPlan || planIndex === undefined) {\n      logProbe('[Strategy:Random] 决策中止：导航计划 (playbackPlan) 尚未初始化。返回 Stop 以策安全。', 'error');\n      logProbe('', 'groupEnd');\n      return { action: 'Stop' };\n    }\n\n    logProbe(`(探针) 当前导航指针 (planIndex): ${planIndex}`);\n    logProbe(`(探针) 导航地图 (playbackPlan): [${playbackPlan.join(', ')}]`);\n\n    const nextPlanIndex = planIndex + 1;\n\n    if (nextPlanIndex < playbackPlan.length) {\n      const targetTrackIndex = playbackPlan[nextPlanIndex];\n      logProbe(\n        `[Strategy:Random] 决策: onTrackEnd -> GoTo (新 planIndex: ${nextPlanIndex}, 目标 trackIndex: ${targetTrackIndex})`,\n      );\n      logProbe('', 'groupEnd');\n      return { action: 'GoTo', nextIndex: targetTrackIndex };\n    } else {\n      logProbe('[Strategy:Random] onTrackEnd 已到达计划终点，委托给 _handlePlanEnd...');\n      logProbe('', 'groupEnd');\n      return this._handlePlanEnd(currentItem);\n    }\n  }\n\n  public onPlaybackError(currentItem: QueueItem): StrategyDecision {\n    logProbe(`[Strategy:Random] 收到 onPlaybackError 请求。决策: 委托给 advance('next')`);\n    return this.advance(currentItem, 'next');\n  }\n}\n\n// =================================================================\n// 2.3. 策略管理器 (The StrategyManager - \"The Conductor\")\n// =================================================================\nconst StrategyManager = (() => {\n  logProbe('[StrategyManager] 模块正在初始化...');\n\n  const _strategies: Record<PlaybackMode, IPlaybackStrategy> = {\n    list: new ListStrategy(),\n    single: new SingleStrategy(),\n    random: new RandomStrategy(),\n  };\n  let _currentStrategy: IPlaybackStrategy = _strategies.list;\n\n  const publicAPI = {\n    /**\n     * [命令] 设置新的播放模式，并自动切换到对应的策略实例。\n     */\n    setMode(mode: PlaybackMode) {\n      logProbe(`[StrategyManager] (Command) setMode: 切换策略模式为 -> ${mode}`);\n      _currentStrategy = _strategies[mode];\n    },\n\n    /**\n     * [查询] 获取当前激活的策略实例。这是我们遵循CQS原则的体现。\n     */\n    getCurrentStrategy: () => _currentStrategy,\n\n    /**\n     * [命令] 通知当前策略：核心状态（如队列）已发生重大变化。\n     * 这是修复BUG的核心，它为策略提供了一个统一的生命周期钩子。\n     */\n\n    notifyQueueChanged() {\n      logProbe(\n        `[StrategyManager] (Command) notifyQueueChanged: 正在通知当前策略 (${_currentStrategy.constructor.name}) 队列已变更...`,\n        'groupCollapsed',\n      );\n      const currentItem = StateManager.getTopQueueItem();\n      _currentStrategy.onQueueChanged(currentItem);\n      logProbe('[StrategyManager] 通知完成。', 'groupEnd');\n    },\n  };\n\n  logProbe('[StrategyManager] 模块初始化完成。');\n  return publicAPI;\n})();\n\n// =================================================================\n// 3. 全局变量与常量 (Global Variables & Constants)\n// =================================================================\n\nconst STATE_KEY = '余烬双星_播放器状态';\n\nlet isInitializedForThisChat = false;\nlet isReconciling = false;\nlet _initializationPromiseControls: { resolve: () => void; reject: (reason?: any) => void } | null = null;\n\nlet _initializationPromise: Promise<void> | null = null;\nlet isScriptActive = true;\nlet allPlaylists: Record<string, PlaylistConfig> = {};\nlet triggers: z.infer<typeof ZodTriggerConfig>[] = [];\nlet defaultPlaylistId: string | undefined = '';\n\nlet isMvuIntegrationActive = false;\nlet isCorePlayerInitialized = false;\nlet _currentChatId: string | number | null = null;\n\nconst fullStateUpdateCallbacks: ((payload: FullStatePayload) => void)[] = [];\nconst timeUpdateCallbacks: ((payload: TimeUpdatePayload) => void)[] = [];\n\n/**\n * [V9.0 统一校准官] 新架构的“运行时大脑”。\n * 它的单一职责是：响应“运行时”的增量事件，通过“边沿检测”模型，\n * 精确地、最小化地修改当前队列，并决策是否需要变更播放。\n * @param eventPayload - 可选的、来自 MVU 事件的最新状态数据。\n */\nasync function _reconcilePlaylistQueue(eventPayload?: any, options?: { transitionEffect?: 'hard' | 'smooth' }) {\n  // --- 1. 【前置检查】: 防止并发的事件风暴 ---\n  if (isReconciling) {\n    logProbe('[Reconciler] 请求被合并：前一个校准任务仍在进行中。', 'warn');\n    return;\n  }\n  isReconciling = true;\n  logProbe('=== [Reconciler] “统一校准官”已接管运行时事件 ===', 'group');\n\n  try {\n    StateManager.setPerformingEffect(true);\n    logProbe('[Reconciler] (事务) 已上效果锁并广播“过渡中”状态，UI应进入等待。');\n    broadcastFullState();\n\n    // --- 核心逻辑 (原有的 try...finally 块) ---\n    try {\n      const oldTopItem = StateManager.getTopQueueItem();\n\n      // --- 2. 【获取事实】: 遵循“时序悖论”定律 ---\n      const currentStateData = eventPayload?.stat_data\n        ? eventPayload.stat_data\n        : ((await _findLatestAuthoritativeMvuState())?.mvuData?.stat_data ?? {});\n\n      logProbe(`[Reconciler] (探针) 已确定本次校准的权威 MVU 状态 (来源: ${eventPayload ? '事件载荷' : '主动查询'})。`);\n\n      // --- 3. 【生成报告】: 委托 MvuManager 进行边沿检测 ---\n      const previousStateData = MvuManager.getPreviousState();\n      const changeReport = MvuManager.calculateChangeReport(previousStateData, currentStateData, triggers);\n\n      // --- 4. 【执行队列的增量修改】: 先减后加 ---\n      const newQueue = StateManager.getQueue();\n\n      if (changeReport.newlyInactiveTriggers.length > 0) {\n        _.remove(newQueue, item =>\n          changeReport.newlyInactiveTriggers.some(inactiveTrigger =>\n            areTriggersFunctionallyEqual(item.triggerSource, inactiveTrigger),\n          ),\n        );\n        logProbe(`[Reconciler] (修改) 根据报告移除了 ${changeReport.newlyInactiveTriggers.length} 个失效项。`);\n      }\n\n      if (changeReport.newlyActiveTriggers.length > 0) {\n        for (const activeTrigger of changeReport.newlyActiveTriggers) {\n          if (\n            newQueue.some(item => item.triggerSource && areTriggersFunctionallyEqual(item.triggerSource, activeTrigger))\n          ) {\n            logProbe(`[Reconciler] (防御) 拒绝添加重复的激活项: \"${activeTrigger.playlist_id}\"`, 'warn');\n            continue;\n          }\n          const newItem = createQueueItem({\n            type: 'mvu',\n            playlistId: activeTrigger.playlist_id,\n            trigger: activeTrigger,\n          });\n          if (newItem) {\n            newQueue.push(newItem);\n            logProbe(`[Reconciler] (修改) 根据报告添加了新激活项: \"${newItem.playlistId}\"`);\n          }\n        }\n      }\n\n      StateManager.updateQueue(newQueue);\n\n      // --- 5. 【决策与执行】: 对比新旧队首 ---\n      const newTopItem = StateManager.getTopQueueItem();\n\n      if (newTopItem?.playlistId !== oldTopItem?.playlistId) {\n        logProbe(\n          `[Reconciler] (决策) 队首发生变更！ 从 \"${oldTopItem?.playlistId ?? '无'}\" 变为 \"${newTopItem?.playlistId ?? '无'}\"。`,\n        );\n\n        if (newTopItem) {\n          logProbe('[Reconciler] (握手) 正在通知 StrategyManager 队列已变更...');\n          StrategyManager.notifyQueueChanged();\n\n          newTopItem.wasEverPlayed = true;\n          const targetIndex = newTopItem.wasEverPlayed ? newTopItem.currentIndex : 0;\n\n          if (StateManager.isPlaying()) {\n            logProbe('[Reconciler] (效果) 用户正在播放，将执行过渡效果...');\n            if (options?.transitionEffect === 'hard') {\n              await PlaybackEngine.executeHardCut(\n                newTopItem.playlistContent[targetIndex].url,\n                StateManager.getVolume(),\n              );\n            } else {\n              await _executeTransition(targetIndex);\n            }\n          } else {\n            logProbe('[Reconciler] (效果) 用户已暂停，仅在后台静默更新轨道，不播放。');\n            const track = newTopItem.playlistContent[targetIndex];\n            const activePlayer = PlaybackEngine.getActivePlayer();\n            if (track && activePlayer) {\n              activePlayer.src = track.url;\n            }\n          }\n        }\n      } else {\n        logProbe('[Reconciler] (决策) 队首未发生变更，保持当前播放稳定。');\n      }\n\n      // --- 6. 【更新记忆】: 为下一次边沿检测做准备 ---\n      await MvuManager.persistCurrentState(currentStateData);\n    } catch (error) {\n      logProbe(`[Reconciler] 核心逻辑执行期间发生严重错误: ${error}`, 'error');\n      console.error(error);\n    } finally {\n      await writeState('reconciliation');\n    }\n  } finally {\n    isReconciling = false;\n    await _releaseEffectLock();\n    logProbe('=== [Reconciler] “统一校准官”任务完成 (锁已通过调度器释放) ===', 'groupEnd');\n  }\n}\n\n// =================================================================\n// 4. 核心工具与广播系统 (Core Utilities & Broadcast System)\n// =================================================================\n\nfunction broadcastFullState() {\n  const currentItem = StateManager.getTopQueueItem();\n  const currentPlaylist = currentItem?.playlistContent ?? [];\n  const currentIndex = currentItem?.currentIndex ?? 0;\n\n  const payload: FullStatePayload = {\n    currentItem: currentPlaylist[currentIndex]\n      ? {\n          title: currentPlaylist[currentIndex].歌名,\n          artist: currentPlaylist[currentIndex].歌手,\n          cover: currentPlaylist[currentIndex].封面,\n        }\n      : null,\n    isPlaying: StateManager.isPlaying(),\n    playbackMode: StateManager.getPlaybackMode(),\n    masterVolume: StateManager.getVolume(),\n    playlist: currentPlaylist.map(item => ({ title: item.歌名, artist: item.歌手, cover: item.封面 })),\n    isTransitioning: StateManager.isPerformingEffect(),\n  };\n  logProbe(\n    `[Broadcast] 正在广播完整状态... isPlaying: ${payload.isPlaying}, mode: ${payload.playbackMode}, currentItem: ${payload.currentItem?.title ?? '无'}`,\n    'groupCollapsed',\n  );\n  logProbe(`详细: isTransitioning=${payload.isTransitioning}`);\n  logProbe('', 'groupEnd');\n\n  fullStateUpdateCallbacks.forEach(callback => {\n    try {\n      callback(payload);\n    } catch (e) {\n      console.error('[音乐脚本] 完整状态回调执行出错:', e);\n    }\n  });\n}\n\nfunction broadcastTimeUpdate() {\n  const activePlayer = PlaybackEngine.getActivePlayer();\n  if (!StateManager.isPlaying() || !activePlayer) return;\n  const payload: TimeUpdatePayload = {\n    currentTime: activePlayer.currentTime,\n    duration: activePlayer.duration || 0,\n  };\n  timeUpdateCallbacks.forEach(callback => callback(payload));\n}\n\nfunction prepareNextTrack() {\n  const currentItem = StateManager.getTopQueueItem();\n  const standbyPlayer = PlaybackEngine.getStandbyPlayer();\n  if (!standbyPlayer || !currentItem) return;\n  const nextIndex = currentItem.currentIndex + 1;\n  if (nextIndex < currentItem.playlistContent.length) {\n    const nextTrack = currentItem.playlistContent[nextIndex];\n    if (nextTrack && standbyPlayer.src !== nextTrack.url) {\n      standbyPlayer.src = nextTrack.url;\n      standbyPlayer.load();\n    }\n  }\n}\n\n// =================================================================\n// 5. 状态管理 (State Management)\n// =================================================================\n\nfunction readState() {\n  logProbe('[StateReader] 正在尝试从酒馆变量读取持久化状态...');\n  const savedData = getVariables({ type: 'chat' })[STATE_KEY];\n\n  if (!savedData || typeof savedData !== 'object') {\n    logProbe('[StateReader] 未发现有效存档。');\n    return null;\n  }\n\n  logProbe('[StateReader] 发现原始状态数据，正在提交给 Zod 进行安全验证...');\n  const validationResult = ZodPersistedState.safeParse(savedData);\n\n  if (validationResult.success) {\n    logProbe('[StateReader] Zod 验证成功，状态数据安全。');\n    return validationResult.data;\n  } else {\n    console.warn('[StateReader] 持久化状态验证失败:', validationResult.error);\n    return null;\n  }\n}\n\nasync function writeState(source: string) {\n  if (!isScriptActive) {\n    logProbe(`[State] 写入操作被阻止，因为脚本正在停机。(来源: ${source})`, 'warn');\n    return;\n  }\n  try {\n    logProbe(`[State] 由 \"${source}\" 触发状态写入...`);\n    const dataToSave = StateManager.getStateSnapshotForPersistence();\n\n    await updateVariablesWith(\n      vars => {\n        vars[STATE_KEY] = dataToSave;\n        return vars;\n      },\n      { type: 'chat' },\n    );\n\n    logProbe(`[State] 状态已成功写入酒馆变量`);\n  } catch (e: any) {\n    logProbe(`[State] 写入状态时发生严重错误: ${e}`, 'error');\n  }\n}\n\n// =================================================================\n// 6. 世界书配置解析与队列操作 (Worldbook Parsing & Stack Operations)\n// =================================================================\n\n/**\n * @description 格式化 Zod 验证错误，以便在 toastr 中为角色卡作者显示清晰、可操作的反馈。\n */\nfunction _formatZodErrorForToastr(error: ZodError): void {\n  const issue = error.issues[0];\n  const path = issue.path.join(' -> ');\n  const message = issue.message;\n\n  const toastrTitle = `[MusicConfig] 内容错误`;\n  const toastrMessage = `路径: ${path} | 问题: ${message}`;\n\n  const fullLogMessage = `[MusicConfig] 内容错误:\\n路径: ${path}\\n问题: ${message}`;\n  logProbe(`[ZodValidator] 世界书配置验证失败: ${fullLogMessage}`, 'error');\n\n  toastr.error(toastrMessage, toastrTitle, { timeOut: 15000 });\n}\n\n// =================================================================\n// 核心算法 V9.5 (Core Algorithms for \"Concerto\")\n// 原则: 这些函数都必须是纯粹的查询 (CQS)，严禁产生任何副作用。\n// =================================================================\n\n/**\n * [核心算法] 判断两个触发器对象是否代表同一个“功能身份”。\n * @param a - 第一个触发器对象。\n * @param b - 第二个触发器对象。\n * @returns {boolean} 如果功能上相等，则返回 true。\n */\nfunction areTriggersFunctionallyEqual(\n  a: z.infer<typeof ZodTriggerConfig> | undefined,\n  b: z.infer<typeof ZodTriggerConfig> | undefined,\n): boolean {\n  if (!a || !b) return a === b;\n\n  if (a.playlist_id !== b.playlist_id) return false;\n\n  type ConditionKey = keyof z.infer<typeof ZodSingleCondition>;\n\n  const getCanonicalString = (condition: z.infer<typeof ZodSingleCondition>): string => {\n    return (Object.keys(condition) as ConditionKey[])\n      .sort()\n      .map(key => `${key}:${String(condition[key])}`) // 使用 String() 来确保所有值都能被正确处理\n      .join(',');\n  };\n\n  const conditionsA = a.conditions.map(getCanonicalString).sort();\n  const conditionsB = b.conditions.map(getCanonicalString).sort();\n\n  return conditionsA.length === conditionsB.length && conditionsA.every((val, index) => val === conditionsB[index]);\n}\n\n/**\n * @description [V9.7 核心强化] 查找权威MVU状态。现在能够识别“创世”和“运行时”两种数据结构。\n * @param context - 可选的上下文，用于指导查找方式。\n * @returns {Promise<{ mvuData: any, messageId: number } | null>} 权威状态或 null。\n */\nasync function _findLatestAuthoritativeMvuState(context?: {\n  messageId: number;\n  swipeId: number;\n}): Promise<{ mvuData: any; messageId: number } | null> {\n  // --- 模式一: 精确制导 (通常用于开场白) ---\n  if (context && context.messageId === 0 && typeof context.swipeId === 'number') {\n    logProbe(\n      `[StateFinder] (精确制导模式) 目标: message_id=${context.messageId}, swipe_id=${context.swipeId}`,\n      'groupCollapsed',\n    );\n    try {\n      const mvuDataContainer: any = await Mvu.getMvuData({ type: 'message', message_id: 0 });\n\n      const swipeSpecificData = mvuDataContainer?.swipes_data?.[context.swipeId];\n\n      if (swipeSpecificData?.stat_data) {\n        // 成功在 \"创世\" 结构中找到特定 swipe 的数据\n        logProbe('[StateFinder] (探针) 检测到“创世”结构 (swipes_data)，成功命中！');\n        logProbe('', 'groupEnd');\n        return { mvuData: swipeSpecificData, messageId: 0 };\n      } else if (mvuDataContainer?.stat_data) {\n        // 在顶层找到了 \"运行时\" 结构的数据 (可能只有一个开场白)\n        logProbe('[StateFinder] (探针) 检测到“运行时”结构 (顶层 stat_data)，直接采用。');\n        logProbe('', 'groupEnd');\n        return { mvuData: mvuDataContainer, messageId: 0 };\n      } else {\n        logProbe('[StateFinder] (精确制导模式) 查找失败：在两种已知结构中均未找到 stat_data。', 'warn');\n      }\n    } catch (error) {\n      logProbe(`[StateFinder] (精确制导模式) 查询时出错: ${error}`, 'error');\n    } finally {\n      logProbe('', 'groupEnd');\n    }\n  }\n\n  // --- 模式二: 回溯扫描 (找不到精确目标时的标准流程) ---\n  logProbe('[StateFinder] (回溯扫描模式) 开始执行...', 'groupCollapsed');\n  try {\n    const allMessages = getChatMessages(-1, { include_swipes: true });\n    for (let i = allMessages.length - 1; i >= 0; i--) {\n      const message = allMessages[i];\n      // [V9.7 核心修正] 修复致命拼写错误：message.id -> message.message_id\n      const currentMessageId = message.message_id;\n\n      // 防御性编程：如果 message_id 无效，直接跳过，防止意外\n      if (typeof currentMessageId !== 'number') {\n        logProbe(`(探针) 跳过无效楼层 (索引 ${i})，因其 message_id 为 ${currentMessageId}。`, 'warn');\n        continue;\n      }\n\n      try {\n        logProbe(`(探针) 正在查询 message_id: ${currentMessageId}...`);\n        const mvuData = await Mvu.getMvuData({ type: 'message', message_id: currentMessageId });\n\n        if (mvuData?.stat_data) {\n          logProbe(`[StateFinder] 查找成功！在 message_id: ${currentMessageId} 处找到权威状态。`);\n          logProbe('', 'groupEnd');\n          return { mvuData, messageId: currentMessageId };\n        }\n      } catch (error) {\n        logProbe(`(探针) 查询 message_id: ${currentMessageId} 时接口失败，将继续向前查找。错误: ${error}`, 'warn');\n      }\n    }\n    logProbe('[StateFinder] 查找失败：遍历完所有消息楼层，均未找到有效的 stat_data。', 'warn');\n    return null;\n  } catch (error) {\n    logProbe(`[StateFinder] 在获取聊天记录时发生严重错误: ${error}`, 'error');\n    return null;\n  } finally {\n    logProbe('', 'groupEnd');\n  }\n}\n\n/**\n * @description [职责单一] 找到、解析、验证并准备好【可供运行时直接使用】的音乐配置。\n * @returns {Promise<{ playlists: Record<string, PlaylistConfig>, defaultId: string, triggers: Trigger[] } | null>}\n *          一个包含了【 playlists 映射 】的、完全准备就绪的配置对象，或在失败时返回 null。\n */\n\nasync function parseWorldbookConfig() {\n  logProbe('[WorldbookParser V3-聚合模式] 开始解析...', 'group');\n\n  type AggregatedPlaylist = z.infer<typeof ZodPlaylistConfig> & { _sourceFile: string };\n  type AggregatedTrigger = z.infer<typeof ZodTriggerConfig> & { _sourceFile: string };\n\n  const aggregatedConfig: {\n    playlists: AggregatedPlaylist[];\n    triggers: AggregatedTrigger[];\n    defaultPlaylistId?: string;\n    _defaultPlaylistIdSourceFile: string | null;\n  } = {\n    playlists: [],\n    triggers: [],\n    defaultPlaylistId: undefined,\n    _defaultPlaylistIdSourceFile: null,\n  };\n\n  try {\n    const worldbookNames = getCharWorldbookNames('current');\n    const searchOrder = [worldbookNames.primary, ...worldbookNames.additional].filter(Boolean);\n    let foundAnyConfig = false;\n\n    for (const bookName of searchOrder) {\n      if (!bookName) continue;\n      const entries = await getWorldbook(bookName);\n      // [新] 查找所有名字包含 `[MusicConfig]` 的条目，而非精确匹配\n      const configEntries = entries.filter(e => e.name.includes('[MusicConfig]'));\n\n      if (configEntries.length > 0) foundAnyConfig = true;\n\n      for (const entry of configEntries) {\n        logProbe(`[Parser V3] 发现并处理配置文件: \"${entry.name}\"`);\n        try {\n          const rawConfig = YAML.parse(entry.content);\n          const validationResult = ZodWorldbookConfig.safeParse(rawConfig);\n\n          if (!validationResult.success) {\n            logProbe(`[Parser V3] 条目 \"${entry.name}\" Zod验证失败，已跳过。`, 'error');\n            _formatZodErrorForToastr(validationResult.error);\n            continue; // 跳过这个错误的文件，继续处理下一个\n          }\n\n          const data = validationResult.data;\n\n          // --- 合并策略执行 ---\n          // [新] 为每个歌单和触发器附加来源信息，用于后续的精确错误报告\n          if (data.playlists) {\n            aggregatedConfig.playlists.push(...data.playlists.map(p => ({ ...p, _sourceFile: entry.name })));\n          }\n          if (data.triggers) {\n            aggregatedConfig.triggers.push(...data.triggers.map(t => ({ ...t, _sourceFile: entry.name })));\n          }\n\n          // [新] 执行“覆盖并警告”策略\n          if (data.default_playlist_id) {\n            if (aggregatedConfig.defaultPlaylistId && aggregatedConfig.defaultPlaylistId !== data.default_playlist_id) {\n              const warningMsg = `在文件 \"${entry.name}\" 中发现的 default_playlist_id (\"${data.default_playlist_id}\") 覆盖了来自文件 \"${aggregatedConfig._defaultPlaylistIdSourceFile ?? '未知'}\" 的定义 (\"${aggregatedConfig.defaultPlaylistId}\")。为确保行为可预测，建议只保留一个定义。`;\n              logProbe(`[Parser V3] ${warningMsg}`, 'warn');\n              toastr.warning(warningMsg, '配置警告', { timeOut: 20000, closeButton: true });\n            }\n            aggregatedConfig.defaultPlaylistId = data.default_playlist_id;\n            aggregatedConfig._defaultPlaylistIdSourceFile = entry.name;\n          }\n        } catch (e: any) {\n          logProbe(`[Parser V3] 解析条目 \"${entry.name}\" 时发生YAML语法错误: ${e.message}`, 'error');\n          toastr.error(`[MusicConfig] 文件 \"${entry.name}\" 格式错误：YAML 语法不正确。`, '配置错误', {\n            timeOut: 10000,\n          });\n        }\n      }\n    }\n\n    if (!foundAnyConfig) {\n      logProbe('[Parser V3] 未在任何世界书中找到 [MusicConfig] 条目。', 'warn');\n      logProbe('', 'groupEnd');\n      return null; // 正常结束，只是没有配置\n    }\n\n    // --- [新] 最终的、全局的健全性检查 ---\n    logProbe('[Parser V3] 所有文件聚合完毕，开始执行全局健全性检查...', 'groupCollapsed');\n    let isGloballyValid = true;\n\n    // 1. 全局歌单ID唯一性检查\n    const playlistsById = _.groupBy(aggregatedConfig.playlists, 'id');\n    for (const id in playlistsById) {\n      if (playlistsById[id].length > 1) {\n        const sources = playlistsById[id].map(p => p._sourceFile).join(', ');\n        const errorMsg = `[MusicConfig] 致命错误: 歌单 ID \"${id}\" 在多个文件中重复定义。来源: ${sources}。ID 必须是唯一的。`;\n        logProbe(errorMsg, 'error');\n        toastr.error(errorMsg, '配置冲突', { timeOut: 15000 });\n        isGloballyValid = false;\n      }\n    }\n\n    const allPlaylistIds = new Set(aggregatedConfig.playlists.map(p => p.id));\n\n    // 2. 全局 default_playlist_id 有效性检查\n    if (aggregatedConfig.defaultPlaylistId && !allPlaylistIds.has(aggregatedConfig.defaultPlaylistId)) {\n      const errorMsg = `[MusicConfig] 配置错误: 最终的 default_playlist_id (\"${aggregatedConfig.defaultPlaylistId}\", 来自文件 \"${aggregatedConfig._defaultPlaylistIdSourceFile ?? '未知'}\") 指向了一个不存在的歌单。`;\n      logProbe(errorMsg, 'error');\n      toastr.error(errorMsg, '配置错误', { timeOut: 15000 });\n      aggregatedConfig.defaultPlaylistId = undefined; // 优雅降级\n    }\n\n    // 3. 全局触发器目标有效性检查\n    const finalTriggers = aggregatedConfig.triggers.filter(trigger => {\n      if (allPlaylistIds.has(trigger.playlist_id)) {\n        return true;\n      }\n      const errorMsg = `[MusicConfig] 校验失败: 来自文件 \"${trigger._sourceFile}\" 的触发器指向了不存在的歌单ID \"${trigger.playlist_id}\"。该触发器将被忽略。`;\n      logProbe(errorMsg, 'error');\n      toastr.error(errorMsg, '配置错误', { timeOut: 10000 });\n      return false;\n    });\n\n    if (!isGloballyValid) {\n      logProbe('[Parser V3] 全局健全性检查失败，配置被拒绝。', 'error');\n      logProbe('', 'groupEnd');\n      logProbe('', 'groupEnd');\n      return null;\n    }\n    logProbe('[Parser V3] 全局健全性检查通过。');\n    logProbe('', 'groupEnd');\n\n    if (aggregatedConfig.playlists.length === 0) {\n      const errorMsg = `[MusicConfig] 致命错误: 所有配置文件中都未能找到任何有效的歌单 (playlists)。播放器无法加载。`;\n      logProbe(errorMsg, 'error');\n      toastr.error(errorMsg, '配置错误', { timeOut: 15000 });\n      logProbe('', 'groupEnd');\n      return null;\n    }\n\n    // --- 数据归一化并返回 ---\n    const playlistsAsMap: Record<string, PlaylistConfig> = {};\n    for (const pl of aggregatedConfig.playlists) {\n      const normalizedTracks = pl.tracks.map(track => ({\n        url: track.url,\n        歌名:\n          track.歌名 && track.歌名.trim() !== ''\n            ? track.歌名\n            : decodeURIComponent(track.url.split('/').pop()?.split('?')[0] || '未知歌曲'),\n        歌手: track.歌手,\n        封面: track.封面,\n      }));\n\n      playlistsAsMap[pl.id] = { ..._.omit(pl, '_sourceFile'), tracks: normalizedTracks };\n    }\n\n    const finalConfig = {\n      playlists: playlistsAsMap,\n      defaultId: aggregatedConfig.defaultPlaylistId,\n      triggers: finalTriggers.map(t => _.omit(t, '_sourceFile')),\n    };\n\n    logProbe('[Parser V3] 数据归一化完成，运行时配置已就绪。', 'log');\n    logProbe('', 'groupEnd');\n    return finalConfig;\n  } catch (error) {\n    logProbe(`[Parser V3] 解析过程中发生意外顶层错误: ${error}`, 'error');\n    toastr.error('音乐配置加载时发生未知错误，请检查控制台日志。');\n    logProbe('', 'groupEnd');\n    return null;\n  }\n}\n\n/**\n * [工厂 V3.0] 从持久化对象重建一个完整的、可供运行时使用的 QueueItem。\n * @param persistedItem - 从酒馆变量读取的、经过 Zod 验证的item。\n * @param playlistConfig - 从当前世界书解析出的对应歌单配置。\n * @returns {QueueItem} 一个完整的运行时 QueueItem。\n */\nfunction reconstituteQueueItem(\n  persistedItem: z.infer<typeof ZodQueueItemState>,\n  playlistConfig: PlaylistConfig,\n): QueueItem {\n  return {\n    playlistId: persistedItem.playlistId,\n    priority: persistedItem.triggerSource?.priority ?? -Infinity,\n    playlistContent: _.cloneDeep(playlistConfig.tracks),\n    onFinishRule: playlistConfig.onFinishRule,\n    currentIndex: persistedItem.currentIndex,\n    playedIndices: new Set(persistedItem.playedIndices),\n    wasEverPlayed: persistedItem.wasEverPlayed,\n    triggeredBy: persistedItem.triggerSource ? 'mvu' : 'base',\n    triggerSource: persistedItem.triggerSource,\n  };\n}\n\ntype CreateQueueItemConfig =\n  | { type: 'base'; playlistId: string }\n  | { type: 'mvu'; playlistId: string; trigger: z.infer<typeof ZodTriggerConfig> };\n\n/**\n * [工厂 V3.0] 创建一个全新的、状态初始化的 QueueItem。\n * @param config - 一个包含所有必要信息的配置对象。\n * @returns {QueueItem | null} 一个完整的队列项，或在失败时返回 null。\n */\nfunction createQueueItem(config: CreateQueueItemConfig): QueueItem | null {\n  const { playlistId } = config;\n\n  if (!playlistId || !allPlaylists[playlistId]) {\n    logProbe(`[Factory] 创建队列项失败：请求的歌单ID \"${playlistId}\" 不存在。`, 'error');\n    return null;\n  }\n\n  const playlistConfig = allPlaylists[playlistId];\n\n  const baseItem: Omit<QueueItem, 'triggeredBy' | 'triggerSource' | 'onFinishRule' | 'priority'> = {\n    playlistId: playlistId,\n    playlistContent: _.cloneDeep(playlistConfig.tracks),\n    currentIndex: 0,\n    playedIndices: new Set(),\n    wasEverPlayed: false,\n  };\n\n  if (config.type === 'base') {\n    return {\n      ...baseItem,\n      priority: -Infinity,\n      triggeredBy: 'base',\n      onFinishRule: 'loop',\n    };\n  } else {\n    return {\n      ...baseItem,\n      priority: config.trigger.priority,\n      triggeredBy: 'mvu',\n      onFinishRule: playlistConfig.onFinishRule,\n      triggerSource: config.trigger,\n    };\n  }\n}\n\n// =================================================================\n// 7. 运行时初始化与播放器控制 (Runtime & Player Controls)\n// =================================================================\n\nasync function initializePlayerForChat(\n  config: any,\n  authoritativeState: any,\n  options?: { autoPlayIfWasPlaying?: boolean },\n) {\n  logProbe('=== 开始执行【核心·自愈式初始化】 V9.0 ===', 'group');\n  try {\n    // --- 【准备阶段】 清理与重置 ---\n    isCorePlayerInitialized = true;\n    StateManager.resetState();\n    MvuManager.resetState();\n    MvuManager.initialize();\n    const activePlayer = PlaybackEngine.getActivePlayer();\n    if (activePlayer) activePlayer.pause();\n    triggers = [];\n    allPlaylists = {};\n    defaultPlaylistId = '';\n\n    if (!config) {\n      logProbe('[Initializer] 配置无效，初始化中止。', 'error');\n      broadcastFullState();\n      // [新增] 如果配置在解析阶段就失败了，我们必须在这里抛出错误以通知前端\n      throw new Error('世界书音乐配置解析失败，请检查配置。');\n    }\n\n    allPlaylists = config.playlists;\n    defaultPlaylistId = config.defaultId;\n    triggers = config.triggers;\n\n    const savedState = readState();\n    const currentStatData = authoritativeState?.mvuData?.stat_data ?? null;\n    const authoritativeMessageId = authoritativeState?.messageId;\n\n    let finalQueue: QueueItem[] = [];\n\n    // --- 【第一步】 确定并验证权威的基础歌单 ID ---\n    let correctBasePlaylistId = defaultPlaylistId;\n    const msgZero = getChatMessages(0, { include_swipes: true })[0];\n    if (msgZero) {\n      const currentGreeting = msgZero.swipes?.[msgZero.swipe_id];\n      const tagMatch = currentGreeting?.match(/<playlist:([^>]+)>/);\n      if (tagMatch && tagMatch[1]) {\n        const tagPlaylistId = tagMatch[1];\n        // [新增] 检查 3: 开场白标签中的歌单是否存在\n        if (allPlaylists[tagPlaylistId]) {\n          logProbe(`[Initializer-Heal] (基准) 从开场白标签确定权威基础歌单: \"${tagPlaylistId}\"`);\n          correctBasePlaylistId = tagPlaylistId;\n        } else {\n          const errorMsg = `[MusicConfig] 配置警告: 开场白标签 <playlist:${tagPlaylistId}> 指向了一个不存在的歌单ID。将回退至默认歌单。`;\n          logProbe(errorMsg, 'warn');\n          toastr.warning(errorMsg, '配置警告', { timeOut: 15000 });\n          // 保持 correctBasePlaylistId 为 defaultPlaylistId\n        }\n      } else {\n        logProbe(`[Initializer-Heal] (基准) 开场白无标签，使用世界书默认歌单: \"${defaultPlaylistId ?? '无'}\"`);\n      }\n    }\n\n    // [新增] 检查 4: 基础歌单与场景歌单冲突检查\n    if (correctBasePlaylistId) {\n      const scenePlaylistIds = new Set(triggers.map(t => t.playlist_id));\n      if (scenePlaylistIds.has(correctBasePlaylistId)) {\n        const fatalErrorMsg = `[MusicConfig] 致命配置错误: 歌单 \"${correctBasePlaylistId}\" 不能同时被用作基础歌单（在开场白或默认设置中）和场景歌单（被触发器关联）。请为它们使用不同的歌单。`;\n        logProbe(fatalErrorMsg, 'error');\n        toastr.error(fatalErrorMsg, '配置冲突', { timeOut: 20000, closeButton: true });\n        // 这是无法解决的逻辑冲突，必须中止初始化\n        throw new Error('基础歌单与场景歌单存在致命冲突。');\n      }\n    }\n\n    // --- 【第二步】 队列净化与重建 (Heal the Past) ---\n    if (savedState) {\n      logProbe('[Initializer-Heal] (净化) 开始审查存档...', 'groupCollapsed');\n      const healedQueue: QueueItem[] = [];\n      for (const persistedItem of savedState.active_queue) {\n        if (!Object.prototype.hasOwnProperty.call(allPlaylists, persistedItem.playlistId)) {\n          logProbe(`(净化-丢弃) 存档歌单 \"${persistedItem.playlistId}\" 已不存在。`, 'warn');\n          continue;\n        }\n\n        const playlistConfig = allPlaylists[persistedItem.playlistId];\n        const isBaseItem = !persistedItem.triggerSource;\n\n        if (isBaseItem) {\n          if (persistedItem.playlistId === correctBasePlaylistId) {\n            logProbe(`(净化-保留) 基础歌单 \"${persistedItem.playlistId}\" 仍然有效。`);\n            healedQueue.push(reconstituteQueueItem(persistedItem, playlistConfig));\n          } else {\n            logProbe(\n              `(净化-丢弃) 基础歌单 \"${persistedItem.playlistId}\" 已被新的权威歌单 \"${correctBasePlaylistId ?? '无'}\" 替代。`,\n              'warn',\n            );\n          }\n        } else {\n          const currentTrigger = triggers.find(t => t.playlist_id === persistedItem.playlistId);\n          logProbe(`(探针-净化) 正在审查存档的MVU歌单 \"${persistedItem.playlistId}\"...`);\n\n          if (playlistConfig.onFinishRule === 'pop') {\n            logProbe(`(净化-丢弃) 原因：规则为 'pop'。`);\n            continue;\n          }\n\n          if (!currentTrigger) {\n            logProbe(`(净化-丢弃) 原因：在最新的世界书配置中已找不到对应的触发器。`, 'warn');\n            continue;\n          }\n\n          if (!MvuManager.checkTriggerCondition(currentTrigger, currentStatData)) {\n            logProbe(`(净化-丢-弃) 原因：最新的触发器条件在当前状态下不满足。`);\n            continue;\n          }\n\n          logProbe(`(净化-保留) 验证通过。`);\n          healedQueue.push(reconstituteQueueItem(persistedItem, playlistConfig));\n        }\n      }\n      finalQueue = healedQueue;\n      logProbe('[Initializer-Heal] (净化) 审查完成。', 'groupEnd');\n    }\n\n    // --- 【第三步】 队列补充 ---\n    if (currentStatData && triggers.length > 0) {\n      logProbe('[Initializer-Heal] (补充) 正在检查是否有新激活的场景歌单...', 'groupCollapsed');\n      for (const trigger of triggers) {\n        const alreadyExists = finalQueue.some(\n          item => item.triggerSource && areTriggersFunctionallyEqual(item.triggerSource, trigger),\n        );\n\n        if (!alreadyExists && MvuManager.checkTriggerCondition(trigger, currentStatData)) {\n          const playlistConfig = allPlaylists[trigger.playlist_id];\n          if (playlistConfig && playlistConfig.onFinishRule === 'pop') {\n            if (authoritativeMessageId === 0) {\n              logProbe(`(补充) 允许添加 'pop' 歌单 \"${trigger.playlist_id}\"，因为上下文是开场白。`);\n              const newItem = createQueueItem({ type: 'mvu', playlistId: trigger.playlist_id, trigger: trigger });\n              if (newItem) finalQueue.push(newItem);\n            } else {\n              logProbe(\n                `(补充-阻止) 场景歌单 \"${trigger.playlist_id}\" 因规则为 'pop' 且上下文非开场白而被忽略。`,\n                'warn',\n              );\n            }\n          } else {\n            const newItem = createQueueItem({ type: 'mvu', playlistId: trigger.playlist_id, trigger: trigger });\n            if (newItem) finalQueue.push(newItem);\n          }\n        }\n      }\n      logProbe('[Initializer-Heal] (补充) 检查完成。', 'groupEnd');\n    }\n\n    // --- 【第四步】 基础歌单最终注入 (Final Guarantee) ---\n    const basePlaylistExists = finalQueue.some(item => item.triggeredBy === 'base');\n    if (!basePlaylistExists && correctBasePlaylistId && allPlaylists[correctBasePlaylistId]) {\n      logProbe(`[Initializer-Heal] (注入) 最终注入权威基础歌单 \"${correctBasePlaylistId}\"。`);\n      const baseItem = createQueueItem({ type: 'base', playlistId: correctBasePlaylistId });\n      if (baseItem) finalQueue.push(baseItem);\n    }\n\n    // --- 【第五步】 最终加载与后续设置 ---\n    logProbe('[Initializer-Finalize] 正在提交最终队列并完成设置...');\n    StateManager.updateQueue(finalQueue);\n\n    const mode = savedState?.mode ?? 'list';\n    StateManager.setPlaybackMode(mode);\n    StrategyManager.setMode(mode);\n    logProbe(`(探针) 策略模式已同步为: ${mode}`);\n    StrategyManager.notifyQueueChanged();\n\n    PlaybackEngine.initialize();\n    const volume = savedState?.volume ?? 0.5;\n    StateManager.setVolume(volume);\n    if (PlaybackEngine.getActivePlayer()) PlaybackEngine.getActivePlayer()!.volume = volume;\n    if (PlaybackEngine.getStandbyPlayer()) PlaybackEngine.getStandbyPlayer()!.volume = 0;\n\n    const initialTopItem = StateManager.getTopQueueItem();\n    if (initialTopItem) {\n      const track = initialTopItem.playlistContent[initialTopItem.currentIndex];\n      if (track && PlaybackEngine.getActivePlayer()) {\n        PlaybackEngine.getActivePlayer()!.src = track.url;\n      }\n    }\n\n    if (currentStatData) {\n      await MvuManager.persistCurrentState(currentStatData);\n      logProbe('[Initializer-Finalize]  已将本次创世的权威MVU状态持久化为历史基准。');\n    } else {\n      await MvuManager.persistCurrentState({});\n      logProbe('[Initializer-Finalize] 当前无MVU状态，已将空状态持久化为历史基准。');\n    }\n\n    await writeState('initialization');\n    broadcastFullState();\n\n    if (options?.autoPlayIfWasPlaying) {\n      logProbe('[Initializer] (探针) 检测到来自开场白滑动的“自动播放”意图。', 'warn');\n      const currentItem = StateManager.getTopQueueItem();\n      if (currentItem) {\n        logProbe('[Initializer] 新的开场白已配置歌单，将执行“创世播放”...');\n        await _handleGenesisPlay();\n      } else {\n        logProbe('[Initializer] 新的开场白未配置歌单，自动播放已取消。');\n      }\n    }\n  } catch (error) {\n    logProbe(`[Initializer] 核心初始化过程中发生严重错误: ${error}`, 'error');\n    console.error(error);\n    // 将错误继续向上抛出，以便 tryInitialize 中的 catch 块可以捕获它并通知前端\n    throw error;\n  } finally {\n    logProbe('=== 【核心·自愈式初始化】执行完毕 ===', 'groupEnd');\n  }\n}\n\n/**\n * @description 【V8.2 核心】播放执行器。\n *              它的单一职责是：接收一个目标索引，并尝试播放它。\n *              它会返回一个 Promise，成功时 resolve，失败时 reject，将错误冒泡给调用者处理。\n *              它自身不包含任何重试或自愈逻辑。\n */\nasync function _executeTransition(targetIndex: number): Promise<void> {\n  logProbe(`[Executor] 收到播放指令，目标索引: ${targetIndex}`, 'group');\n\n  const freshItem = StateManager.getTopQueueItem();\n  if (!freshItem) {\n    logProbe(`[Executor] 执行中止：无有效队列项`, 'warn');\n    logProbe('', 'groupEnd');\n    return Promise.resolve();\n  }\n\n  const targetTrack = freshItem.playlistContent[targetIndex];\n  if (!targetTrack?.url) {\n    logProbe(`[Executor] 执行失败：在索引 ${targetIndex} 处找不到音轨或音轨URL无效。`, 'error');\n    logProbe('', 'groupEnd');\n    throw new Error(`Invalid track at index ${targetIndex}`);\n  }\n\n  try {\n    await PlaybackEngine.transitionToTrack(targetTrack.url, StateManager.getVolume());\n\n    StateManager.setPlaying(true);\n    prepareNextTrack();\n    logProbe(`[Executor] 索引 ${targetIndex} 播放成功。`);\n  } catch (error) {\n    logProbe(`[Executor] PlaybackEngine报告播放失败。原因: ${error}`, 'error');\n    throw error;\n  } finally {\n    logProbe('', 'groupEnd');\n  }\n}\n\n/**\n * @description 【V8.2 核心】迭代式自愈循环。\n *              此最终版严格遵守 SRP 原则，将决策应用逻辑完全委托给 _applyNavigationDecision。\n */\nasync function _executeSelfHealingLoop(): Promise<void> {\n  logProbe('[SelfHeal] 启动“迭代式自愈循环”... 播放器进入紧急自愈模式。', 'warn');\n\n  let consecutiveFailures = 1;\n  const currentItemForThreshold = StateManager.getTopQueueItem();\n  const threshold = currentItemForThreshold?.playlistContent.length ?? 0;\n\n  if (currentItemForThreshold) {\n    toastr.error(\n      `歌曲《${currentItemForThreshold.playlistContent[currentItemForThreshold.currentIndex]?.歌名 ?? '未知歌曲'}》加载失败，正在尝试自动处理...`,\n    );\n  }\n\n  while (true) {\n    if (threshold > 0 && consecutiveFailures >= threshold) {\n      logProbe(\n        `[SelfHeal] (熔断器) 连续失败 ${consecutiveFailures} 次，已达到或超过阈值 ${threshold}。自愈中止。`,\n        'error',\n      );\n      if (currentItemForThreshold) {\n        toastr.error(`歌单《${currentItemForThreshold.playlistId}》中所有歌曲均无法加载，播放已停止。`);\n      }\n      StateManager.setPlaying(false);\n      broadcastFullState();\n      return;\n    }\n\n    const currentItem = StateManager.getTopQueueItem();\n    if (!currentItem) {\n      logProbe('[SelfHeal] 自愈中止：中途队列变空。', 'warn');\n      StateManager.setPlaying(false);\n      broadcastFullState();\n      return;\n    }\n\n    const errorDecision = StrategyManager.getCurrentStrategy().onPlaybackError(currentItem);\n    logProbe(\n      `[SelfHeal] 收到策略 (${StrategyManager.getCurrentStrategy().constructor.name}) 的错误决策: { action: '${errorDecision.action}' }`,\n    );\n\n    const directive = await _applyNavigationDecision(errorDecision);\n\n    if (!directive.needsAsyncEffect) {\n      logProbe('[SelfHeal] 决策应用后无需播放，自愈中止。');\n      // 注意：applyNavigationDecision 内部已经处理了 setPlaying(false) 和广播\n      return;\n    }\n\n    // 防御性编程：确保 targetIndex 存在\n    if (typeof directive.targetIndex !== 'number') {\n      logProbe('[SelfHeal] 决策应用后需要播放，但没有有效的 targetIndex。自愈中止。', 'error');\n      StateManager.setPlaying(false);\n      broadcastFullState();\n      return;\n    }\n\n    // 步骤 4: 再次尝试播放\n    try {\n      await _executeTransition(directive.targetIndex);\n\n      logProbe('[SelfHeal] 播放成功，自愈循环结束。', 'log');\n      broadcastFullState();\n      return;\n    } catch (nextError) {\n      consecutiveFailures++;\n      const nextTopItem = StateManager.getTopQueueItem();\n      const nextTrackTitle = nextTopItem?.playlistContent[nextTopItem.currentIndex]?.歌名 ?? '未知歌曲';\n      logProbe(`[SelfHeal] 第 ${consecutiveFailures} 次播放失败:`, 'error');\n      console.error(nextError);\n      toastr.error(`下一首《${nextTrackTitle}》加载失败...`);\n    }\n  }\n}\n\nasync function _applyNavigationDecision(\n  decision: StrategyDecision,\n): Promise<{ needsAsyncEffect: boolean; targetIndex?: number }> {\n  logProbe(\n    `[CentralCommand] 正在应用策略决策: { action: '${decision.action}', nextIndex: ${decision.nextIndex ?? 'N/A'} }`,\n    'group',\n  );\n\n  let needsAsyncEffect = false;\n  let targetIndex: number | undefined;\n\n  const currentItem = StateManager.getTopQueueItem();\n\n  switch (decision.action) {\n    case 'GoTo': {\n      if (typeof decision.nextIndex === 'number') {\n        logProbe('[CentralCommand] 指令: GoTo。提交导航步骤...');\n        StateManager.commitNavigationStep(decision.nextIndex);\n        needsAsyncEffect = true;\n        targetIndex = decision.nextIndex;\n      } else {\n        logProbe('[CentralCommand] 致命逻辑错误: GoTo 指令缺少 nextIndex！这是一个策略模块的BUG。', 'error');\n        console.error('探针捕获：错误的决策对象:', decision);\n        console.error('探针捕获：发生错误时的播放器状态:', StateManager.getStateSnapshotForRuntime());\n        needsAsyncEffect = false;\n      }\n      break;\n    }\n\n    case 'Restart': {\n      logProbe('[CentralCommand] 指令: Restart。请求从头重播当前轨道。');\n      if (currentItem) {\n        logProbe('[CentralCommand] (探针) 此决策不改变状态索引，仅生成一个效果指令。');\n        needsAsyncEffect = true;\n        targetIndex = currentItem.currentIndex;\n      }\n      break;\n    }\n\n    case 'RemoveTopAndAdvance': {\n      logProbe('[CentralCommand] 指令: RemoveTopAndAdvance。正在执行【自洽式】队列修改与过渡...'); // [修改] 日志内容\n      const currentQueue = StateManager.getQueue();\n\n      const poppedItem = currentQueue.shift();\n      logProbe(`(探针) 已从队列中移除: \"${poppedItem?.playlistId}\"`);\n\n      StateManager.updateQueue(currentQueue);\n\n      logProbe('[CentralCommand] (握手) 正在通知 StrategyManager 队列已变更...');\n      StrategyManager.notifyQueueChanged();\n\n      const newTopItem = StateManager.getTopQueueItem();\n      if (newTopItem) {\n        logProbe(`(决策) 新队首为 \"${newTopItem.playlistId}\"，准备过渡到其当前索引: ${newTopItem.currentIndex}`);\n        needsAsyncEffect = true;\n        targetIndex = newTopItem.currentIndex;\n      } else {\n        logProbe('(决策) 队列已空，停止播放。');\n        StateManager.setPlaying(false);\n        needsAsyncEffect = false;\n      }\n\n      break;\n    }\n\n    case 'LoopReset': {\n      logProbe('[CentralCommand] 指令: LoopReset。执行“指挥家模型”...', 'warn');\n      StateManager.resetCurrentItemForLoop();\n      const currentMode = StateManager.getPlaybackMode();\n      if (currentMode === 'random') {\n        logProbe('(指挥) 检测到随机模式，向作曲家索要新乐谱...');\n        const genesisPlan = (StrategyManager.getCurrentStrategy() as RandomStrategy).prepareGenesis(\n          StateManager.getTopQueueItem(),\n        );\n        if (genesisPlan) {\n          StateManager.commitGenesisState(\n            genesisPlan.newCurrentIndex,\n            genesisPlan.newPlaybackPlan,\n            genesisPlan.newPlanIndex,\n          );\n        }\n      }\n      const finalStartIndex = StateManager.getTopQueueItem()?.currentIndex ?? 0;\n      logProbe(`(指挥) 流程完成。最终确定的新起始索引为: ${finalStartIndex}`);\n      needsAsyncEffect = true;\n      targetIndex = finalStartIndex;\n      break;\n    }\n\n    case 'Stop': {\n      logProbe('[CentralCommand] 指令: Stop。停止播放。');\n      StateManager.setPlaying(false);\n      break;\n    }\n\n    case 'DoNothing':\n    default:\n      logProbe(`[CentralCommand] 指令: DoNothing。无状态变更。`);\n      break;\n  }\n\n  if (decision.action !== 'RemoveTopAndAdvance') {\n    broadcastFullState();\n  }\n\n  const directive = { needsAsyncEffect, targetIndex };\n  logProbe(\n    `[CentralCommand] 决策应用完成。返回指令: { needsAsyncEffect: ${directive.needsAsyncEffect}, targetIndex: ${directive.targetIndex ?? 'N/A'} }`,\n  );\n  logProbe('', 'groupEnd');\n  return directive;\n}\n\n/**\n * @description [V9.6 净化] 释放效果锁并广播最终状态。\n *              这是所有异步控制器 finally 块中的标准“谢幕”程序。\n */\nasync function _releaseEffectLock() {\n  // 探针: 记录锁释放的动作，这对于调试UI卡死问题至关重要\n  logProbe('[LockManager] 正在释放效果锁并广播最终状态...');\n\n  StateManager.setPerformingEffect(false);\n  broadcastFullState();\n}\n\nasync function _handleTrackEnded() {\n  logProbe('[Controller:TrackEnd] === 开始处理轨道自然结束事件 ===', 'group');\n  if (StateManager.isPerformingEffect()) {\n    logProbe('[Controller:TrackEnd] 请求被拒绝，因为效果正在执行。', 'warn');\n    logProbe('', 'groupEnd');\n    return;\n  }\n\n  const currentItem = StateManager.getTopQueueItem();\n  if (!currentItem) {\n    logProbe('[Controller:TrackEnd] 请求中止：队列为空。');\n    logProbe('', 'groupEnd');\n    return;\n  }\n\n  try {\n    StateManager.setPerformingEffect(true);\n    broadcastFullState();\n\n    const decision = StrategyManager.getCurrentStrategy().onTrackEnd(currentItem);\n    const directive = await _applyNavigationDecision(decision);\n\n    if (directive.needsAsyncEffect && typeof directive.targetIndex === 'number') {\n      await _executeTransition(directive.targetIndex);\n    }\n  } catch (error) {\n    logProbe(`[Controller:TrackEnd] 在执行效果时捕获到错误，将启动自愈循环...`, 'error');\n    console.error(error);\n    await _executeSelfHealingLoop();\n  } finally {\n    await _releaseEffectLock();\n    await writeState('trackEnded');\n    logProbe('[Controller:TrackEnd] === 轨道结束事件处理完毕 (锁已通过调度器释放) ===', 'groupEnd');\n  }\n}\n\n// =================================================================\n// 8. 全局API与事件系统 (Global API & Event System)\n// =================================================================\n\nasync function _handleNavigation(direction: 'next' | 'prev') {\n  logProbe(`[Controller:Nav] === 开始处理用户导航事件 (方向: ${direction}) ===`, 'group');\n  if (StateManager.isPerformingEffect()) {\n    logProbe(`[Controller:Nav] 请求被拒绝，因为效果正在执行。`, 'warn');\n    logProbe('', 'groupEnd');\n    return;\n  }\n\n  const currentItem = StateManager.getTopQueueItem();\n  if (!currentItem) {\n    logProbe(`[Controller:Nav] 请求中止：队列为空。`);\n    logProbe('', 'groupEnd');\n    return;\n  }\n\n  try {\n    StateManager.setPerformingEffect(true);\n    broadcastFullState();\n\n    const decision = StrategyManager.getCurrentStrategy().advance(currentItem, direction);\n    const directive = await _applyNavigationDecision(decision);\n\n    logProbe(\n      `[Controller:Nav] (探针) 原始决策: ${decision.action}, 处理指令: needsAsyncEffect=${directive.needsAsyncEffect}`,\n    );\n\n    if (decision.action === 'Restart') {\n      logProbe(`[Controller:Nav] 检测到 Restart 决策，执行 seek(0) 效果。`);\n      const activePlayer = PlaybackEngine.getActivePlayer();\n      if (activePlayer) activePlayer.currentTime = 0;\n      if (StateManager.getPlaybackMode() !== 'single') {\n        toastr.info('已是第一首');\n      }\n    } else if (directive.needsAsyncEffect && typeof directive.targetIndex === 'number') {\n      await _executeTransition(directive.targetIndex);\n    } else if (decision.action === 'DoNothing') {\n      toastr.info(direction === 'next' ? '已是歌单最后一首。' : '已是歌单第一首。');\n    }\n  } catch (error) {\n    logProbe(`[Controller:Nav] 在执行效果时捕获到错误，将启动自愈循环...`, 'error');\n    console.error(error);\n    await _executeSelfHealingLoop();\n  } finally {\n    await _releaseEffectLock();\n    await writeState('navigation');\n    logProbe(`[Controller:Nav] === 用户导航事件处理完毕 (锁已通过调度器释放) ===`, 'groupEnd');\n  }\n}\n\nasync function _handleGenesisPlay() {\n  if (StateManager.isPerformingEffect()) {\n    logProbe('[Controller:Genesis] 请求被拒绝，因为效果正在执行。', 'warn');\n    return;\n  }\n\n  const currentItem = StateManager.getTopQueueItem();\n  if (!currentItem) {\n    logProbe('[Controller:Genesis] 请求中止：播放列表为空。');\n    return;\n  }\n\n  try {\n    StateManager.setPerformingEffect(true);\n    logProbe(`[Controller:Genesis] === “创世播放”效果开始 (目标索引: ${currentItem.currentIndex}) ===`, 'group');\n\n    StateManager.setPlaying(true);\n\n    broadcastFullState();\n\n    await _executeTransition(currentItem.currentIndex);\n  } catch (error) {\n    logProbe(`[Controller:Genesis] “创世播放”效果执行时发生意外顶层错误: ${error}`, 'error');\n    StateManager.setPlaying(false);\n    broadcastFullState();\n  } finally {\n    await _releaseEffectLock();\n    await writeState('genesisPlay');\n    logProbe(`[Controller:Genesis] === “创世播放”效果结束 (锁已通过调度器释放) ===`, 'groupEnd');\n  }\n}\n\nasync function _handlePlayIndex(index: number) {\n  logProbe(`[Controller:PlayIndex] === 开始处理索引播放事件 (目标: ${index}) ===`, 'group');\n  if (StateManager.isPerformingEffect()) {\n    logProbe(`[Controller:PlayIndex] 请求被拒绝，因为效果正在执行。`, 'warn');\n    logProbe('', 'groupEnd');\n    return;\n  }\n\n  try {\n    StateManager.setPerformingEffect(true);\n    broadcastFullState();\n\n    const currentItem = StateManager.getTopQueueItem();\n    const currentMode = StateManager.getPlaybackMode();\n\n    if (currentItem && index === currentItem.currentIndex) {\n      logProbe(`[Controller:PlayIndex] (决策) 用户点击了当前歌曲，将从头重播。`);\n      const activePlayer = PlaybackEngine.getActivePlayer();\n      if (activePlayer) activePlayer.currentTime = 0;\n    } else if (currentMode === 'list' || currentMode === 'single') {\n      logProbe(`[Controller:PlayIndex] (决策) ${currentMode} 模式，执行标准跳转...`);\n      StateManager.setCurrentIndex(index);\n      await _executeTransition(index);\n    } else if (currentMode === 'random') {\n      logProbe(`[Controller:PlayIndex] (决策) random 模式，执行“用户跳转”高级逻辑...`);\n      StateManager.userInitiatedJump(index);\n      await _executeTransition(index);\n    }\n  } catch (error) {\n    logProbe(`[Controller:PlayIndex] 在执行效果时捕获到错误，将启动自愈循环...`, 'error');\n    console.error(error);\n    await _executeSelfHealingLoop();\n  } finally {\n    await _releaseEffectLock();\n    await writeState('playIndex');\n    logProbe(`[Controller:PlayIndex] === 索引播放事件处理完毕 (锁已通过调度器释放) ===`, 'groupEnd');\n  }\n}\n\nasync function togglePlayPause() {\n  logProbe('[Controller:Toggle] === 开始处理播放/暂停切换事件 ===', 'group');\n  if (StateManager.isPerformingEffect()) {\n    logProbe('[Controller:Toggle] 请求被拒绝，因为效果正在执行。', 'warn');\n    logProbe('', 'groupEnd');\n    return;\n  }\n  const currentItem = StateManager.getTopQueueItem();\n  if (!currentItem) {\n    logProbe('[Controller:Toggle] 请求中止：播放列表为空。');\n    toastr.info('播放列表为空');\n    logProbe('', 'groupEnd');\n    return;\n  }\n\n  try {\n    StateManager.setPerformingEffect(true);\n    broadcastFullState();\n\n    let decision: { action: 'pause' | 'resume' | 'playNew'; targetIndex?: number };\n    const activePlayer = PlaybackEngine.getActivePlayer();\n    const logicalIndex = currentItem.currentIndex;\n    const physicalSrc = activePlayer?.src;\n    const logicalSrc = currentItem.playlistContent[logicalIndex]?.url;\n\n    if (StateManager.isPlaying()) {\n      decision = { action: 'pause' };\n    } else if (activePlayer && physicalSrc === logicalSrc && activePlayer.currentTime > 0) {\n      decision = { action: 'resume' };\n    } else {\n      decision = { action: 'playNew', targetIndex: logicalIndex };\n    }\n\n    if (decision.action !== 'pause') StateManager.setPlaying(true);\n    else StateManager.setPlaying(false);\n\n    broadcastFullState();\n\n    switch (decision.action) {\n      case 'pause':\n        await PlaybackEngine.fadeOutAndPause();\n        break;\n      case 'resume':\n        await PlaybackEngine.resumeAndFadeIn(StateManager.getVolume());\n        break;\n      case 'playNew':\n        if (typeof decision.targetIndex === 'number') {\n          await _executeTransition(decision.targetIndex);\n        }\n        break;\n    }\n  } catch (error) {\n    logProbe(`[Controller:Toggle] 在执行效果时捕获到错误，将启动自愈循环...`, 'error');\n    console.error(error);\n    await _executeSelfHealingLoop();\n  } finally {\n    await _releaseEffectLock();\n    await writeState('togglePlayPause');\n    logProbe('[Controller:Toggle] === 播放/暂停切换事件处理完毕 (锁已通过调度器释放) ===', 'groupEnd');\n  }\n}\n\nfunction playNext() {\n  void _handleNavigation('next');\n}\n\nfunction playPrev() {\n  void _handleNavigation('prev');\n}\n\nfunction setupGlobalAPI() {\n  window.musicPlayerAPI = {\n    requestInitialization: (): Promise<void> => {\n      if (isInitializedForThisChat) {\n        logProbe('[API] requestInitialization (已完成): 一个迟到的界面发来请求，立即返回成功契约。');\n        broadcastFullState();\n        return Promise.resolve();\n      }\n\n      if (!_initializationPromise) {\n        logProbe('[API] requestInitialization (首次): 第一个界面请求到达，正在创建【共享的】Promise契约...');\n        _initializationPromise = new Promise((resolve, reject) => {\n          _initializationPromiseControls = { resolve, reject };\n        });\n      } else {\n        logProbe('[API] requestInitialization (后续): 又一个界面请求到达，返回【已存在的】共享契约。');\n      }\n\n      return _initializationPromise;\n    },\n\n    togglePlayPause: () => togglePlayPause(),\n    playNext: () => playNext(),\n    playPrev: () => playPrev(),\n    playIndex: (index: number) => {\n      const currentItem = StateManager.getTopQueueItem();\n      if (currentItem && index >= 0 && index < currentItem.playlistContent.length) {\n        void _handlePlayIndex(index);\n      }\n    },\n    persistVolumeAndBroadcast: (volume: number) => {\n      const finalVolume = Math.max(0, Math.min(1, volume));\n      const activePlayer = PlaybackEngine.getActivePlayer();\n      StateManager.setVolume(finalVolume);\n      if (activePlayer && !StateManager.isPerformingEffect()) activePlayer.volume = finalVolume;\n      void writeState('persistVolume');\n      broadcastFullState();\n    },\n    setLiveVolume: (volume: number) => {\n      const activePlayer = PlaybackEngine.getActivePlayer();\n      if (activePlayer && !StateManager.isPerformingEffect()) activePlayer.volume = Math.max(0, Math.min(1, volume));\n    },\n\n    setPlaybackMode: (mode: PlaybackMode) => {\n      logProbe(`=== 开始执行【模式切换】事务 (请求: ${mode}) ===`, 'group');\n      const oldMode = StateManager.getPlaybackMode();\n      if (mode === oldMode) {\n        logProbe(`[ModeSwitch] 模式未变更 (仍为 ${mode})，事务提前中止。`);\n        logProbe('', 'groupEnd');\n        return;\n      }\n\n      StateManager.setPlaybackMode(mode);\n      StrategyManager.setMode(mode);\n\n      logProbe(`[ModeSwitch] 策略已切换为: ${StrategyManager.getCurrentStrategy().constructor.name}`);\n\n      if (oldMode === 'random') {\n        logProbe('[ModeSwitch] 正在为旧模式 \"random\" 执行“离开”生命周期钩子...');\n        StateManager.clearRandomModePlan();\n      }\n      if (mode === 'random') {\n        logProbe('[ModeSwitch] 正在为新模式 \"random\" 执行“进入”生命周期钩子...');\n        StrategyManager.notifyQueueChanged();\n      }\n\n      void writeState('setPlaybackMode');\n      broadcastFullState();\n      logProbe('=== 【模式切换】事务执行完毕 ===', 'groupEnd');\n    },\n    seekTo: (percentage: number) => {\n      const activePlayer = PlaybackEngine.getActivePlayer();\n      if (activePlayer?.duration) activePlayer.currentTime = activePlayer.duration * percentage;\n    },\n    getCurrentState: (): FullStatePayload => {\n      const i = StateManager.getTopQueueItem();\n      const c = i?.playlistContent ?? [];\n      const x = i?.currentIndex ?? 0;\n      const stateToReturn: FullStatePayload = {\n        currentItem: c[x] ? { title: c[x].歌名, artist: c[x].歌手, cover: c[x].封面 } : null,\n        isPlaying: StateManager.isPlaying(),\n        playbackMode: StateManager.getPlaybackMode(),\n        masterVolume: StateManager.getVolume(),\n        playlist: c.map(t => ({ title: t.歌名, artist: t.歌手, cover: t.封面 })),\n        isTransitioning: StateManager.isPerformingEffect(),\n      };\n      logProbe('[探针 B] 前端主动调用 getCurrentState 获取初始状态，后台返回的数据如下:', 'warn');\n      console.dir(stateToReturn);\n      return stateToReturn;\n    },\n    onFullStateUpdate: (c: (payload: FullStatePayload) => void) => {\n      if (typeof c === 'function') fullStateUpdateCallbacks.push(c);\n    },\n    onTimeUpdate: (c: (payload: TimeUpdatePayload) => void) => {\n      if (typeof c === 'function') timeUpdateCallbacks.push(c);\n    },\n  };\n  initializeGlobal('musicPlayerAPI', window.musicPlayerAPI);\n}\n\n// =================================================================\n// 9. 酒馆集成与主执行区 (Tavern Integration & Main Execution)\n// =================================================================\n\nfunction executeHardReset() {\n  logProbe('[HardReset] “优雅停机”协议启动...', 'warn');\n\n  isScriptActive = false;\n\n  PlaybackEngine.getActivePlayer()?.pause();\n  logProbe('[HardReset] 音频已暂停。');\n\n  logProbe('[HardReset] 即将调用 reloadIframe()。');\n  reloadIframe();\n}\n\nasync function tryInitialize() {\n  if (isInitializedForThisChat) return;\n\n  const currentChatId = SillyTavern.getCurrentChatId ? SillyTavern.getCurrentChatId() : null;\n\n  if (SillyTavern.chat.length > 0 && currentChatId !== null) {\n    // [原则: SRP] isInitializedForThisChat 标志现在是这个函数的“守卫”，确保初始化只执行一次。\n    isInitializedForThisChat = true;\n    _currentChatId = currentChatId;\n\n    logProbe(`【初始化指挥官 V9.8】锁定ID: ${_currentChatId}，开始执行“分流-等待-执行”协议...`, 'group');\n\n    try {\n      // --- 步骤一：检测 (Detect) ---\n      // [原则: SSoT] 初始化流程的第一个动作，就是获取“世界书”这个唯一事实来源。\n      const config = await parseWorldbookConfig();\n      if (!config) {\n        throw new Error('无法解析世界书配置，初始化中止。');\n      }\n\n      const isMvuCard = config.triggers && Array.isArray(config.triggers) && config.triggers.length > 0;\n      logProbe(`(探针-决策) 作者意图判断 -> 是MVU卡吗? ${isMvuCard}`);\n\n      // --- 步骤二：分流 (Branch) & 等待 (Wait) ---\n      if (isMvuCard) {\n        logProbe('【指挥官】(路径选择) 检测到MVU卡，进入“安全路径”，开始等待MVU就绪...');\n        // [原则: CQS] _waitForMvuGenesis 是一个“查询”，它询问外部环境状态，直到满足条件。\n        const mvuIsReady = await _waitForMvuGenesis();\n        if (!mvuIsReady) {\n          throw new Error('MVU集成初始化失败或超时，部分功能将不可用。');\n        }\n        logProbe('【指挥官】MVU已完全就绪，可以安全继续。');\n      } else {\n        logProbe('【指挥官】(路径选择) 检测到纯文字卡，进入“快速路径”。');\n      }\n\n      // --- 步骤三：执行 (Execute) ---\n      logProbe('【指挥官】所有前置条件满足，开始执行播放器核心初始化...');\n\n      let authoritativeState = null;\n      if (isMvuCard) {\n        logProbe('【指挥官】(查询) 正在为MVU卡查找权威状态...');\n        authoritativeState = await _findLatestAuthoritativeMvuState();\n      } else {\n        logProbe('【指挥官】(跳过) 纯文字卡，无需查找MVU状态。');\n      }\n\n      await initializePlayerForChat(config, authoritativeState);\n\n      _registerContextualEventListeners();\n\n      if (_initializationPromiseControls) {\n        logProbe('【指挥官】(探针) 后台初始化成功，兑现 Promise 契约，唤醒前端。');\n        _initializationPromiseControls.resolve();\n      }\n    } catch (error) {\n      logProbe(`【指挥官】在初始化主流程中发生严重错误: ${error}`, 'error');\n      // 如果发生任何错误，都要通知前端，让它显示错误信息\n      if (_initializationPromiseControls) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        _initializationPromiseControls.reject(errorMessage);\n      }\n    } finally {\n      _initializationPromiseControls = null;\n      logProbe('【初始化指挥官 V9.8】协议执行完毕。', 'groupEnd');\n    }\n  }\n}\n\nfunction _registerMvuEventListeners() {\n  logProbe('[EventDispatcher] 正在注册【运行时】MVU 事件监听器...');\n\n  const createReconcileHandler = (eventName: string) => {\n    return (eventPayload?: any) => {\n      if (!isMvuIntegrationActive || !isCorePlayerInitialized) {\n        logProbe(`[Gatekeeper] 捕获到MVU事件 (${eventName})，但系统未就绪，已忽略。`, 'warn');\n        return;\n      }\n      logProbe(`[Event] 捕获到MVU事件: ${eventName}，即将唤醒校准官...`);\n      // (SSoT原则) 将事件载荷这个“事实”直接传递给校准官\n      void _reconcilePlaylistQueue(eventPayload);\n    };\n  };\n\n  eventOn(Mvu.events.VARIABLE_UPDATE_ENDED, createReconcileHandler('VARIABLE_UPDATE_ENDED'));\n  eventOn(tavern_events.MESSAGE_DELETED, createReconcileHandler('MESSAGE_DELETED'));\n\n  logProbe('[EventDispatcher] MVU监听器部署完毕。');\n}\n\n/**\n * [V9.1 核心处理器] 统一处理所有导致“运行时历史”变更的事件。\n * 职责：重新查找权威状态，然后调用校准官进行状态同步。\n * @param eventName - 触发此处理器的事件名，用于日志记录。\n */\nasync function _handleHistoryChangeEvent(eventName: string, options?: { transitionEffect?: 'hard' | 'smooth' }) {\n  logProbe(`[HistoryChange] 检测到历史变更事件: ${eventName}。`);\n  if (!isCorePlayerInitialized) return;\n\n  logProbe(`[HistoryChange-Probe] 正在查询最新的权威MVU状态...`);\n  const authoritativeState = await _findLatestAuthoritativeMvuState();\n\n  if (!authoritativeState?.mvuData) {\n    logProbe('[HistoryChange] (守门员) 未找到有效的权威状态。这在AI重新生成期间是正常现象。', 'warn');\n    logProbe('[HistoryChange] (守门员) 采取“静默等待”策略，本次校准已跳过。');\n    return;\n  }\n\n  console.log(`[HistoryChange-Probe] 查询完毕，这是找到的权威状态数据，请您审查：`);\n  console.dir(_.cloneDeep(authoritativeState?.mvuData));\n\n  await _reconcilePlaylistQueue(authoritativeState?.mvuData, options);\n}\n\n/**\n * [V9.9 核心修正] 处理新AI消息渲染事件的专用处理器。\n * 它的职责是检查并立即注入 <playmusic/> 标签，以修复刷新竞态条件BUG。\n * (SRP: Single Responsibility Principle)\n * @param messageId - 由事件传来的消息ID。\n */\nasync function _handleNewAssistantMessage(messageId: number): Promise<void> {\n  logProbe(`[Injector] 捕获到 CHARACTER_MESSAGE_RENDERED 事件，message_id: ${messageId}`);\n\n  if (messageId === 0) {\n    logProbe(`[Injector] (探针) 操作中止：message_id 为 0 (开场白)，无需注入。`);\n    return;\n  }\n\n  try {\n    const message = getChatMessages(messageId)?.[0];\n\n    if (message?.role === 'assistant' && !message.message.includes('<DarkBramblePlayer/>')) {\n      logProbe(`[Injector] (探针) 条件满足，立即为 message_id: ${messageId} 执行注入...`);\n\n      await setChatMessages([{ message_id: messageId, message: `${message.message}\\n<DarkBramblePlayer/>` }]);\n\n      logProbe(`[Injector] (探针) 注入成功。`);\n    } else {\n      logProbe(`[Injector] (探针) 操作跳过：消息不满足注入条件 (可能不是AI消息，或已包含标签)。`);\n    }\n  } catch (error) {\n    logProbe(`[Injector] 为 message_id: ${messageId} 注入标签时发生严重错误:`, 'error');\n    console.error(error);\n  }\n}\n\n/**\n * [V9.0 核心] 执行一次“软重置”。\n * 这将在不刷新整个页面的情况下，重新执行完整的初始化流程。\n * 用于响应“开场白滑动”等根本性的上下文变更。\n */\nasync function _executeSoftReset(options?: { autoPlayIfWasPlaying?: boolean }) {\n  logProbe('[SoftReset] 检测到根本性上下文变更，启动“软重置”协议...', 'warn');\n  try {\n    const config = await parseWorldbookConfig();\n\n    logProbe('[SoftReset] 正在为新的开场白查找权威MVU状态...');\n    const authoritativeState = await _findLatestAuthoritativeMvuState();\n\n    await initializePlayerForChat(config, authoritativeState, options);\n  } catch (error) {\n    logProbe('[SoftReset] 软重置过程中发生严重错误。', 'error');\n    console.error(error);\n  }\n}\n\nfunction _registerContextualEventListeners() {\n  logProbe('[EventDispatcher] 正在注册“上下文专属”事件监听器...');\n\n  eventOn(tavern_events.CHARACTER_MESSAGE_RENDERED, (id: number) => {\n    void _handleNewAssistantMessage(id);\n  });\n\n  eventOn(tavern_events.MESSAGE_SWIPED, (id: number) => {\n    logProbe(`[Event] 捕获到滑动事件 (message_id: ${id})。`);\n    if (!isCorePlayerInitialized) return;\n\n    if (id === 0) {\n      logProbe('[Event-Swipe] 判断为开场白滑动，执行软重置...');\n      const wasPlaying = StateManager.isPlaying();\n      logProbe(`[Event-Swipe] (探针) 软重置前的播放状态: ${wasPlaying}`);\n      void _executeSoftReset({ autoPlayIfWasPlaying: wasPlaying });\n    } else {\n      logProbe('[Event-Swipe] 判断为历史消息滑动，执行历史变更处理...');\n      void _handleHistoryChangeEvent('MESSAGE_SWIPED', { transitionEffect: 'hard' });\n    }\n  });\n\n  logProbe('[EventDispatcher] “上下文专属”事件监听器注册完毕。');\n}\n\n/**\n * [原则: SRP] 这个函数的单一职责是：作为一个返回 Promise 的“观察哨”，\n * 它只负责“等待MVU创世完成”这一件事。成功则 resolve(true)，失败或超时则 resolve(false)。\n * 所有后续操作（如注册事件）都作为成功后的“副作用”在内部执行。\n */\nasync function _waitForMvuGenesis(): Promise<boolean> {\n  logProbe('【安全观察哨】已上岗，开始执行MVU就绪检查...', 'group');\n\n  try {\n    // [探针] 阶段一：等待 MVU 框架本身出现\n    await waitGlobalInitialized('Mvu');\n    logProbe('【观察哨】(探针) 阶段一成功：MVU 框架已加载。');\n  } catch (e) {\n    logProbe(`【观察哨】(探针) 阶段一失败: ${e}。`, 'warn');\n    logProbe('【安全观察哨】任务失败。', 'groupEnd');\n    return false;\n  }\n\n  // [探针] 阶段二：轮询观察，等待 MVU 将初始数据写入消息楼层\n  const WATCHER_TIMEOUT = 10000;\n  const WATCHER_INTERVAL = 250;\n  const startTime = Date.now();\n  let isGenesisComplete = false;\n\n  logProbe('【观察哨】(探针) 阶段二开始：正在严密监视 message_id: 0 的创世数据...');\n  while (Date.now() - startTime < WATCHER_TIMEOUT) {\n    try {\n      const mvuData: any = await Mvu.getMvuData({ type: 'message', message_id: 0 });\n      if (mvuData && (mvuData.swipes_data || mvuData.stat_data)) {\n        logProbe('【观察哨】(探针) 阶段二成功：在消息楼层中确认到创世数据！');\n        isGenesisComplete = true;\n        break;\n      }\n    } catch (error) {\n      /* 在MVU启动初期，查询失败是正常现象，静默处理 */\n    }\n    await new Promise(resolve => setTimeout(resolve, WATCHER_INTERVAL));\n  }\n\n  if (!isGenesisComplete) {\n    logProbe('【观察哨】(探针) 阶段二失败：观察超时！', 'error');\n    logProbe('【安全观察哨】任务失败。', 'groupEnd');\n    return false;\n  }\n\n  // [探针] 阶段三：所有条件满足，执行激活序列\n  logProbe('【观察哨】(探针) 阶段三开始：执行MVU集成激活序列...');\n  try {\n    _registerMvuEventListeners();\n    isMvuIntegrationActive = true;\n    logProbe('【观察哨】(探针) 阶段三成功：MVU集成已完全激活。');\n    logProbe('【安全观察哨】任务成功完成！', 'groupEnd');\n    return true;\n  } catch (error) {\n    logProbe(`【观察哨】(探针) 阶段三失败：激活序列发生意外崩溃: ${error}`, 'error');\n    isMvuIntegrationActive = false;\n    logProbe('【安全观察哨】任务失败。', 'groupEnd');\n    return false;\n  }\n}\n\n$(() => {\n  logProbe('音乐播放器脚本 V8.4 “上下文感知” 启动');\n  PlaybackEngine.initialize();\n  setupGlobalAPI();\n\n  eventOn(tavern_events.CHAT_CHANGED, () => {\n    logProbe(`[硬重置] CHAT_CHANGED 事件触发，检测到聊天上下文变更。即将执行“优雅停机”协议。`, 'warn');\n    executeHardReset();\n  });\n\n  const observerInterval = setInterval(() => {\n    void tryInitialize();\n    if (isInitializedForThisChat) {\n      clearInterval(observerInterval);\n      logProbe('【观察者模型】初始化成功，观察者已销毁。');\n    }\n  }, 250);\n\n  setTimeout(() => {\n    if (!isInitializedForThisChat) {\n      clearInterval(observerInterval);\n      logProbe('【观察者模型】初始化超时！', 'error');\n\n      if (_initializationPromiseControls) {\n        _initializationPromiseControls.reject('Initialization timed out after 10 seconds.');\n        _initializationPromiseControls = null;\n      }\n    }\n  }, 10000);\n\n  $(window).on('pagehide', () => {\n    logProbe('PAGEHIDE 事件触发！', 'warn');\n\n    PlaybackEngine.getActivePlayer()?.pause();\n    logProbe('音频已暂停。');\n  });\n});\n"],"names":["z","performance","now","ZodTrackConfig","object","string","optional","url","message","strict","ZodSingleCondition","variable_path","greater_than","number","greater_than_or_equal_to","less_than","less_than_or_equal_to","value","union","boolean","value_contains","time_in_range","regex","ZodTriggerConfig","type","literal","playlist_id","priority","default","conditions","array","nonempty","ZodPlaylistConfig","id","onFinishRule","enum","tracks","ZodWorldbookConfig","default_playlist_id","playlists","triggers","ZodQueueItemState","playlistId","currentIndex","playedIndices","wasEverPlayed","triggerSource","ZodPersistedState","active_queue","mode","volume","min","max","previousMvuState","record","any","STATE_KEY_MVU_HISTORY","_parseTimeToMinutes","timeStr","cleanStr","trim","replace","match","hours","parseInt","minutes","MvuManager","_previousMvuState","_checkTriggerCondition","trigger","statData","condition","currentValue","_","get","conditionMet","isHandled","undefined","includes","currentTimeInMinutes","startStr","endStr","split","startMinutes","endMinutes","checkTriggerCondition","initialize","savedState","getVariables","error","resetState","persistCurrentState","currentStateData","isScriptActive","cloneDeep","updateVariablesWith","vars","getPreviousState","calculateChangeReport","previousStateData","allTriggers","report","newlyActiveTriggers","newlyInactiveTriggers","wasMet","isMet","push","length","StateManager","_activePlaylistQueue","_playbackMode","_masterVolume","_isPlaying","_isPerformingEffect","_applyDepartureIsHistoryPrinciple","item","departingIndex","add","getPlaybackMode","getVolume","isPlaying","isPerformingEffect","getTopQueueItem","getQueue","getStateSnapshotForRuntime","getStateSnapshotForPersistence","map","omit","Array","from","loadState","stateToLoad","setPlaybackMode","setVolume","setPlaying","playing","setPerformingEffect","isPerforming","updateQueue","newQueue","sort","a","b","setCurrentIndex","index","currentItem","commitNavigationStep","newTrackIndex","playbackPlan","newPlanIndex","indexOf","planIndex","clearHistoryForCurrentItem","clear","resetCurrentItemForLoop","commitGenesisState","newCurrentIndex","newPlaybackPlan","userInitiatedJump","trackIndex","this","clearRandomModePlan","applyNewPlaybackPlan","plan","PlaybackEngine","_playerA","_playerB","_activePlayer","_standbyPlayer","_fadeInterval","_fadeVolumeAsync","player","targetVolume","duration","Promise","resolve","clearInterval","startVolume","steps","volumeStep","currentStep","window","setInterval","createPlayer","audio","Audio","preload","crossOrigin","addEventListener","async","broadcastFullState","decision","StrategyManager","getCurrentStrategy","onTrackEnd","directive","_applyNavigationDecision","needsAsyncEffect","targetIndex","_executeTransition","_executeSelfHealingLoop","_releaseEffectLock","writeState","_handleTrackEnded","broadcastTimeUpdate","getActivePlayer","getStandbyPlayer","transitionToTrack","targetTrackUrl","slice","Error","standbyPlayer","activePlayer","src","load","reject","onCanPlay","removeEventListener","onError","e","target","pause","newActivePlayer","playPromise","play","fadeOutAndPause","executeHardCut","resumeAndFadeIn","ListStrategy","onQueueChanged","_currentItem","advance","direction","playlistContent","totalTracks","nextIndex","action","lastIndex","totalValidTracks","size","onPlaybackError","SingleStrategy","RandomStrategy","_generateIntelligentShuffle","allTrackIndices","sourceForShuffle","filter","i","has","j","Math","floor","random","join","_generatePlaybackPlan","shuffledIndices","knownSequence","Set","_handlePlanEnd","allIndices","shuffled","prepareGenesis","nextPlanIndex","targetTrackIndex","prevPlanIndex","_strategies","list","single","_currentStrategy","setMode","notifyQueueChanged","constructor","name","STATE_KEY","isInitializedForThisChat","isReconciling","_initializationPromiseControls","_initializationPromise","allPlaylists","defaultPlaylistId","isMvuIntegrationActive","isCorePlayerInitialized","_currentChatId","fullStateUpdateCallbacks","timeUpdateCallbacks","_reconcilePlaylistQueue","eventPayload","options","oldTopItem","stat_data","_findLatestAuthoritativeMvuState","mvuData","changeReport","remove","some","inactiveTrigger","areTriggersFunctionallyEqual","activeTrigger","newItem","createQueueItem","newTopItem","transitionEffect","track","currentPlaylist","payload","title","artist","cover","playbackMode","masterVolume","playlist","isTransitioning","forEach","callback","currentTime","source","dataToSave","_formatZodErrorForToastr","issue","issues","path","toastrMessage","toastr","timeOut","getCanonicalString","Object","keys","key","String","conditionsA","conditionsB","every","val","context","messageId","swipeId","mvuDataContainer","Mvu","getMvuData","message_id","swipeSpecificData","swipes_data","allMessages","getChatMessages","include_swipes","currentMessageId","parseWorldbookConfig","aggregatedConfig","_defaultPlaylistIdSourceFile","worldbookNames","getCharWorldbookNames","searchOrder","primary","additional","Boolean","foundAnyConfig","bookName","configEntries","getWorldbook","entry","rawConfig","YAML","parse","content","validationResult","safeParse","success","data","p","_sourceFile","t","warningMsg","warning","closeButton","isGloballyValid","playlistsById","groupBy","errorMsg","allPlaylistIds","finalTriggers","playlistsAsMap","pl","normalizedTracks","decodeURIComponent","pop","defaultId","reconstituteQueueItem","persistedItem","playlistConfig","Infinity","triggeredBy","config","baseItem","initializePlayerForChat","authoritativeState","savedData","readState","currentStatData","authoritativeMessageId","finalQueue","correctBasePlaylistId","msgZero","currentGreeting","swipes","swipe_id","tagMatch","tagPlaylistId","fatalErrorMsg","healedQueue","prototype","hasOwnProperty","call","currentTrigger","find","initialTopItem","autoPlayIfWasPlaying","_handleGenesisPlay","freshItem","targetTrack","nextTrack","prepareNextTrack","consecutiveFailures","currentItemForThreshold","threshold","errorDecision","nextError","nextTopItem","nextTrackTitle","currentQueue","shift","genesisPlan","finalStartIndex","_handleNavigation","info","setupGlobalAPI","musicPlayerAPI","requestInitialization","togglePlayPause","logicalIndex","physicalSrc","logicalSrc","playNext","playPrev","playIndex","currentMode","_handlePlayIndex","persistVolumeAndBroadcast","finalVolume","setLiveVolume","oldMode","seekTo","percentage","getCurrentState","c","x","onFullStateUpdate","onTimeUpdate","initializeGlobal","tryInitialize","currentChatId","SillyTavern","getCurrentChatId","chat","isMvuCard","isArray","waitGlobalInitialized","WATCHER_TIMEOUT","WATCHER_INTERVAL","startTime","Date","isGenesisComplete","setTimeout","createReconcileHandler","eventName","eventOn","events","VARIABLE_UPDATE_ENDED","tavern_events","MESSAGE_DELETED","_registerMvuEventListeners","_waitForMvuGenesis","CHARACTER_MESSAGE_RENDERED","role","setChatMessages","_handleNewAssistantMessage","MESSAGE_SWIPED","wasPlaying","_executeSoftReset","_handleHistoryChangeEvent","errorMessage","$","CHAT_CHANGED","reloadIframe","observerInterval","on"],"sourceRoot":""}